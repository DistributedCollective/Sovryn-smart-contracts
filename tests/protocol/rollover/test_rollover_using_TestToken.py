'''
Tests the rollover function
'''

import pytest
from fixedint import *
from loanToken.sov_reward import verify_sov_reward_payment
import shared


def setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, loan_token_sent, leverage_amount, set_demand_curve, sovryn):
    set_demand_curve()
    SUSD.approve(loanToken.address, 10 ** 40)
    lender = accounts[0]
    borrower = accounts[1]
    loanToken.mint(lender, 10 ** 30)
    SUSD.mint(borrower, loan_token_sent)
    SUSD.approve(loanToken.address, loan_token_sent, {'from': borrower})
    SUSD.mint(borrower, loan_token_sent)
    SUSD.approve(sovryn.address, loan_token_sent, {'from': borrower})
    SUSD.approve(sovryn.address, loan_token_sent)
    tx = loanToken.marginTrade(
        "0",  # loanId  (0 for new loans)
        leverage_amount,  # leverageAmount
        loan_token_sent,  # loanTokenSent
        0,  # no collateral token sent
        RBTC.address,  # collateralTokenAddress
        borrower,  # trader,
        b'',  # loanDataBytes (only required with ether)
        {'from': borrower}
    )
    loan_id = tx.events['Trade']['loanId']
    loan = sovryn.getLoan(loan_id).dict()
    time_until_loan_end = loan['endTimestamp'] - chain.time()
    chain.sleep(time_until_loan_end)
    chain.mine(1)
    return borrower, loan, loan_id


"""
Tests paid interests to lender
Test that loan attributes are updated
Test loan swap event
"""
def test_rollover(accounts, chain, loanToken, set_demand_curve, sovryn, priceFeeds, SUSD, RBTC, BZRX, SOV, FeesEvents):
    borrower, loan, loan_id = setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, 100e18, 2e18, set_demand_curve, sovryn)
    lender_interest_data = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    lender_pool_initial_balance = SUSD.balanceOf(loanToken.address)
    sov_borrower_initial_balance = SOV.balanceOf(borrower)
    tx_rollover = sovryn.rollover(loan_id, b'')
    tx_rollover.info()

    lender_interest_after = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    lending_fee_percent = sovryn.lendingFeePercent()
    interest_unpaid = lender_interest_data['interestUnPaid']
    lending_fee = fixedint(interest_unpaid).mul(lending_fee_percent).div(1e20)
    interest_owed_now = fixedint(interest_unpaid).sub(lending_fee)
    assert(SUSD.balanceOf(loanToken.address) == fixedint(lender_pool_initial_balance).add(interest_owed_now))
    assert(lender_interest_after['interestPaid'] == interest_unpaid)
    assert(lender_interest_after['interestUnPaid'] == 0)

    # Settles and pays borrowers based on fees generated by their interest payments
    if sovryn.protocolTokenHeld() != 0:
        verify_sov_reward_payment(tx_rollover, FeesEvents, SOV, borrower, loan_id, sov_borrower_initial_balance, 2)

    loan_after = sovryn.getLoan(loan_id).dict()
    assert(loan_after['endTimestamp'] >= loan['endTimestamp'] + 28*24*60*60)

    (trade_rate, precision) = priceFeeds.queryRate(RBTC.address, SUSD.address)
    trading_fee_percent = sovryn.tradingFeePercent()
    trading_fee = fixedint(interest_unpaid).mul(trading_fee_percent).div(1e20)
    loan_swap_event = tx_rollover.events['LoanSwap']
    assert(loan_swap_event['loanId'] == loan_id)
    assert(loan_swap_event['sourceToken'] == RBTC.address)
    assert(loan_swap_event['destToken'] == SUSD.address)
    assert(loan_swap_event['borrower'] == borrower)
    #source buffer = 10000 in sovryn swap connector
    assert(fixedint(loan_swap_event['sourceAmount']).sub(interest_unpaid).add(trading_fee).mul(precision).div(trade_rate).num <= 10000)
    assert(loan_swap_event['destAmount'] >= interest_unpaid)

    rollover_event = tx_rollover.events['Rollover']
    assert(rollover_event['user'] == borrower)
    assert(rollover_event['lender'] == loanToken.address)
    assert(rollover_event['loanId'] == loan_id)
    assert(rollover_event['principal'] == loan_after['principal'])
    assert(rollover_event['collateral'] == loan_after['collateral'])
    assert(rollover_event['endTimestamp'] == loan_after['endTimestamp'])
    assert(rollover_event['rewardReceiver'] == accounts[0]) #sender
    assert(rollover_event['reward'] > 0)

def test_rollover_tiny_amount(accounts, chain, loanToken, set_demand_curve, sovryn, priceFeeds, SUSD, RBTC, BZRX, SOV, FeesEvents):
    constants = shared.Constants()
    loan_token_sent = (constants.TINY_AMOUNT + 1) * 10**4
    borrower, loan, loan_id = setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, loan_token_sent, 1e18, set_demand_curve, sovryn)

    time_until_loan_end = loan['endTimestamp'] - chain.time()
    chain.sleep(time_until_loan_end)
    chain.mine(1)

    tx_rollover = sovryn.rollover(loan_id, b'', {'from': borrower})
    tx_rollover.info()

    loan_after = sovryn.getLoan(loan_id).dict()
    assert(loan_after['principal'] == 0)
    assert(loan_after['collateral'] == 0)
    print(loan_after)

"""
Collateral should decrease
Sender collateral balance should increase
"""
def test_rollover_reward_payment(accounts, chain, loanToken, set_demand_curve, sovryn, priceFeeds, SUSD, RBTC):
    borrower, initial_loan, loan_id = setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, 100e18, 2e18, set_demand_curve, sovryn)

    time_until_loan_end = initial_loan['endTimestamp'] - chain.time()
    chain.sleep(time_until_loan_end)
    chain.mine(1)
    lender_interest_data = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    receiver = accounts[3]
    assert(RBTC.balanceOf(receiver) == 0)
    tx_rollover = sovryn.rollover(loan_id, b'', {'from': receiver})

    end_loan = sovryn.getLoan(loan_id).dict()

    interest_unpaid = lender_interest_data['interestUnPaid']
    (trade_rate, precision) = priceFeeds.queryRate(RBTC.address, SUSD.address)
    trading_fee_percent = sovryn.tradingFeePercent()
    trading_fee = fixedint(interest_unpaid).mul(trading_fee_percent).div(1e20)
    source_token_amount_used = tx_rollover.events['LoanSwap']['sourceAmount']

    # end_collateral = initial_loan['collateral'] - source_token_amount_used - rollover_reward
    rollover_reward = initial_loan['collateral'] - source_token_amount_used - end_loan['collateral']

    assert(RBTC.balanceOf(receiver) >= rollover_reward)
