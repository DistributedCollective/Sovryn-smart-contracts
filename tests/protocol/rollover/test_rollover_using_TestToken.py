'''
Tests the rollover function
'''

import pytest
from fixedint import *
from loanToken.sov_reward import verify_sov_reward_payment


def setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, set_demand_curve, sovryn):
    set_demand_curve()
    SUSD.approve(loanToken.address, 10 ** 40)
    lender = accounts[0]
    borrower = accounts[1]
    loanToken.mint(lender, 10 ** 30)
    loan_token_sent = 100e18
    SUSD.mint(borrower, loan_token_sent)
    SUSD.approve(loanToken.address, loan_token_sent, {'from': borrower})
    tx = loanToken.marginTrade(
        "0",  # loanId  (0 for new loans)
        2e18,  # leverageAmount
        loan_token_sent,  # loanTokenSent
        0,  # no collateral token sent
        RBTC.address,  # collateralTokenAddress
        borrower,  # trader,
        b'',  # loanDataBytes (only required with ether)
        {'from': borrower}
    )
    loan_id = tx.events['Trade']['loanId']
    loan = sovryn.getLoan(loan_id).dict()
    time_until_loan_end = loan['endTimestamp'] - chain.time()
    chain.sleep(time_until_loan_end)
    chain.mine(1)
    return borrower, loan, loan_id


"""
Tests paid interests to lender
Test that loan attributes are updated
Test loan swap event
"""
def test_rollover(accounts, chain, loanToken, set_demand_curve, sovryn, priceFeeds, SUSD, RBTC, BZRX, SOV, FeesEvents):
    borrower, loan, loan_id = setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, set_demand_curve, sovryn)
    lender_interest_data = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    lender_pool_initial_balance = SUSD.balanceOf(loanToken.address)
    sov_borrower_initial_balance = SOV.balanceOf(borrower)
    tx_rollover = sovryn.rollover(loan_id, b'')

    lender_interest_after = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    lending_fee_percent = sovryn.lendingFeePercent()
    interest_unpaid = lender_interest_data['interestUnPaid']
    lending_fee = fixedint(interest_unpaid).mul(lending_fee_percent).div(1e20)
    interest_owed_now = fixedint(interest_unpaid).sub(lending_fee)
    assert(SUSD.balanceOf(loanToken.address) == fixedint(lender_pool_initial_balance).add(interest_owed_now))
    assert(lender_interest_after['interestPaid'] == interest_unpaid)
    assert(lender_interest_after['interestUnPaid'] == 0)

    # Settles and pays borrowers based on fees generated by their interest payments
    if sovryn.protocolTokenHeld() != 0:
        verify_sov_reward_payment(tx_rollover, FeesEvents, SOV, borrower, loan_id, sov_borrower_initial_balance, 2)

    loan_after = sovryn.getLoan(loan_id).dict()
    assert(loan_after['endTimestamp'] >= loan['endTimestamp'] + 28*24*60*60)

    (trade_rate, precision) = priceFeeds.queryRate(RBTC.address, SUSD.address)
    trading_fee_percent = sovryn.tradingFeePercent()
    trading_fee = fixedint(interest_unpaid).mul(trading_fee_percent).div(1e20)
    loan_swap_event = tx_rollover.events['LoanSwap']
    assert(loan_swap_event['loanId'] == loan_id)
    assert(loan_swap_event['sourceToken'] == RBTC.address)
    assert(loan_swap_event['destToken'] == SUSD.address)
    assert(loan_swap_event['borrower'] == borrower)
    #source buffer = 10000 in sovryn swap connector
    assert(fixedint(loan_swap_event['sourceAmount']).sub(interest_unpaid).add(trading_fee).mul(precision).div(trade_rate).num <= 10000)
    assert(loan_swap_event['destAmount'] >= interest_unpaid)


"""
Collateral should decrease
Sender collateral balance should increase
"""
def test_rollover_reward_payment(accounts, chain, loanToken, set_demand_curve, sovryn, priceFeeds, SUSD, RBTC):
    borrower, initial_loan, loan_id = setup_rollover_test(RBTC, SUSD, accounts, chain, loanToken, set_demand_curve, sovryn)

    time_until_loan_end = initial_loan['endTimestamp'] - chain.time()
    chain.sleep(time_until_loan_end)
    chain.mine(1)
    lender_interest_data = sovryn.getLenderInterestData(loanToken.address, SUSD.address).dict()

    receiver = accounts[3]
    assert(RBTC.balanceOf(receiver) == 0)
    tx_rollover = sovryn.rollover(loan_id, b'', {'from': receiver})

    end_loan = sovryn.getLoan(loan_id).dict()

    interest_unpaid = lender_interest_data['interestUnPaid']
    (trade_rate, precision) = priceFeeds.queryRate(RBTC.address, SUSD.address)
    trading_fee_percent = sovryn.tradingFeePercent()
    trading_fee = fixedint(interest_unpaid).mul(trading_fee_percent).div(1e20)
    source_token_amount_used = tx_rollover.events['LoanSwap']['sourceAmount']

    # end_collateral = initial_loan['collateral'] - source_token_amount_used - rollover_reward
    rollover_reward = initial_loan['collateral'] - source_token_amount_used - end_loan['collateral']

    assert(RBTC.balanceOf(receiver) >= rollover_reward)
