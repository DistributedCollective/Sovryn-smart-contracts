diff --git a/node_modules/hardhat/internal/hardhat-network/jsonrpc/client.js b/node_modules/hardhat/internal/hardhat-network/jsonrpc/client.js
index 18c76b5..0c953f0 100644
--- a/node_modules/hardhat/internal/hardhat-network/jsonrpc/client.js
+++ b/node_modules/hardhat/internal/hardhat-network/jsonrpc/client.js
@@ -1,14 +1,14 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
-    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
-}) : (function(o, m, k, k2) {
+    Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
+}) : (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
     o[k2] = m[k];
 }));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
     Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
+}) : function (o, v) {
     o["default"] = v;
 });
 var __importStar = (this && this.__importStar) || function (mod) {
@@ -141,6 +141,60 @@ class JsonRpcClient {
             reward: (0, io_ts_1.optional)(t.array(t.array(base_types_1.rpcQuantity))),
         }), (res) => res.oldestBlock + BigInt(res.baseFeePerGas.length));
     }
+    _patchRawResult(method, rawResult) {
+        /**
+         * Patch the raw results returned by _send or _sendBatch to fix RSK/Hardhat compatibility issues.
+         */
+        if (
+            method.startsWith('eth_getBlock') &&
+            rawResult &&
+            rawResult.transactions && rawResult.transactions.length
+        ) {
+            /*
+                * Calling a forked node (hardhat node --fork MY_RSK_NODE_RPC_URL) fails with:
+                * eth_call
+                * Invalid JSON-RPC response's result.
+                * Errors: Invalid value null supplied to : RpcBlockWithTransactions | null/transactions:
+                * RpcTransaction Array/0: RpcTransaction/v: QUANTITY, Invalid value null supplied to :
+                * RpcBlockWithTransactions | null/transactions: RpcTransaction Array/0: RpcTransaction/r:
+                * QUANTITY, Invalid value null supplied to : RpcBlockWithTransactions | null/transactions:
+                * RpcTransaction Array/0: RpcTransaction/s: QUANTITY
+                *
+                * This patch is based on:
+                * https://gist.github.com/0x0scion/0422f9135bc37642ba36d55b59e8b424
+                *
+                * More reading:
+                * https://github.com/NomicFoundation/hardhat/issues/2395
+                * https://github.com/NomicFoundation/hardhat/pull/2313/files
+                * https://github.com/NomicFoundation/hardhat/issues/2106
+                */
+            rawResult.transactions.forEach((t) => {
+                // Accesslist is sometimes missing, for other networks and maybe for RSK too
+                if (!t.accessList) t.accessList = [];
+                // Some RSK txs have null vrs
+                //       from: '0x0000000000000000000000000000000000000000',
+                //       to: '0x0000000000000000000000000000000001000008',
+                //       gas: '0x0',
+                //       gasPrice: '0x0',
+                //       value: '0x0',
+                //       input: '0x',
+                //       v: null,
+                //       r: null,
+                //       s: null
+                if (!t.v) t.v = '0x0';
+                if (!t.r) t.r = '0x0';
+                if (!t.s) t.s = '0x0';
+            });
+        } else if (method === 'eth_getStorageAt') {
+            /*
+                * This fixes the error in eth_getStorageAt that says 0x0 is an invalid value for DATA
+                */
+            if (rawResult === '0x0') {
+                rawResult = '0x0000000000000000000000000000000000000000000000000000000000000000';
+            }
+        }
+        return rawResult;
+    }
     async getLatestBlockNumber() {
         return this._perform("eth_blockNumber", [], base_types_1.rpcQuantity, (blockNumber) => blockNumber);
     }
@@ -157,7 +211,8 @@ class JsonRpcClient {
                 return diskCachedResult;
             }
         }
-        const rawResult = await this._send(method, params);
+        let rawResult = await this._send(method, params);
+        rawResult = this._patchRawResult(method, rawResult);
         const decodedResult = (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(rawResult, tType);
         const blockNumber = getMaxAffectedBlockNumber(decodedResult);
         if (this._canBeCached(blockNumber)) {
@@ -186,7 +241,13 @@ class JsonRpcClient {
             }
         }
         const rawResults = await this._sendBatch(batch);
-        const decodedResults = rawResults.map((result, i) => (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(result, batch[i].tType));
+        const decodedResults = rawResults.map((result, i) => {
+            result = this._patchRawResult(batch[i].method, result);
+            return (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(
+                result,
+                batch[i].tType
+            );
+        });
         const blockNumber = getMaxAffectedBlockNumber(decodedResults);
         if (this._canBeCached(blockNumber)) {
             this._storeInCache(cacheKey, decodedResults);
diff --git a/node_modules/hardhat/internal/hardhat-network/jsonrpc/client_orig.js b/node_modules/hardhat/internal/hardhat-network/jsonrpc/client_orig.js
new file mode 100644
index 0000000..0cbd464
--- /dev/null
+++ b/node_modules/hardhat/internal/hardhat-network/jsonrpc/client_orig.js
@@ -0,0 +1,304 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
+}) : (function (o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function (o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.JsonRpcClient = void 0;
+const ethereumjs_util_1 = require("@nomicfoundation/ethereumjs-util");
+const fs_extra_1 = __importDefault(require("fs-extra"));
+const t = __importStar(require("io-ts"));
+const path_1 = __importDefault(require("path"));
+const base_types_1 = require("../../core/jsonrpc/types/base-types");
+const block_1 = require("../../core/jsonrpc/types/output/block");
+const decodeJsonRpcResponse_1 = require("../../core/jsonrpc/types/output/decodeJsonRpcResponse");
+const log_1 = require("../../core/jsonrpc/types/output/log");
+const receipt_1 = require("../../core/jsonrpc/types/output/receipt");
+const transaction_1 = require("../../core/jsonrpc/types/output/transaction");
+const hash_1 = require("../../util/hash");
+const io_ts_1 = require("../../util/io-ts");
+class JsonRpcClient {
+    constructor(_httpProvider, _networkId, _latestBlockNumberOnCreation, _maxReorg, _forkCachePath) {
+        this._httpProvider = _httpProvider;
+        this._networkId = _networkId;
+        this._latestBlockNumberOnCreation = _latestBlockNumberOnCreation;
+        this._maxReorg = _maxReorg;
+        this._forkCachePath = _forkCachePath;
+        this._cache = new Map();
+    }
+    getNetworkId() {
+        return this._networkId;
+    }
+    async getDebugTraceTransaction(transactionHash) {
+        return this._perform("debug_traceTransaction", [(0, ethereumjs_util_1.bufferToHex)(transactionHash)], t.object, () => undefined);
+    }
+    // Storage key must be 32 bytes long
+    async getStorageAt(address, position, blockNumber) {
+        return this._perform("eth_getStorageAt", [
+            address.toString(),
+            (0, base_types_1.numberToRpcQuantity)(position),
+            (0, base_types_1.numberToRpcQuantity)(blockNumber),
+        ], base_types_1.rpcData, () => blockNumber);
+    }
+    async getBlockByNumber(blockNumber, includeTransactions = false) {
+        if (includeTransactions) {
+            return this._perform("eth_getBlockByNumber", [(0, base_types_1.numberToRpcQuantity)(blockNumber), true], (0, io_ts_1.nullable)(block_1.rpcBlockWithTransactions), (block) => block?.number ?? undefined);
+        }
+        return this._perform("eth_getBlockByNumber", [(0, base_types_1.numberToRpcQuantity)(blockNumber), false], (0, io_ts_1.nullable)(block_1.rpcBlock), (block) => block?.number ?? undefined);
+    }
+    async getBlockByHash(blockHash, includeTransactions = false) {
+        if (includeTransactions) {
+            return this._perform("eth_getBlockByHash", [(0, ethereumjs_util_1.bufferToHex)(blockHash), true], (0, io_ts_1.nullable)(block_1.rpcBlockWithTransactions), (block) => block?.number ?? undefined);
+        }
+        return this._perform("eth_getBlockByHash", [(0, ethereumjs_util_1.bufferToHex)(blockHash), false], (0, io_ts_1.nullable)(block_1.rpcBlock), (block) => block?.number ?? undefined);
+    }
+    async getTransactionByHash(transactionHash) {
+        return this._perform("eth_getTransactionByHash", [(0, ethereumjs_util_1.bufferToHex)(transactionHash)], (0, io_ts_1.nullable)(transaction_1.rpcTransaction), (tx) => tx?.blockNumber ?? undefined);
+    }
+    async getTransactionCount(address, blockNumber) {
+        return this._perform("eth_getTransactionCount", [(0, ethereumjs_util_1.bufferToHex)(address), (0, base_types_1.numberToRpcQuantity)(blockNumber)], base_types_1.rpcQuantity, () => blockNumber);
+    }
+    async getTransactionReceipt(transactionHash) {
+        return this._perform("eth_getTransactionReceipt", [(0, ethereumjs_util_1.bufferToHex)(transactionHash)], (0, io_ts_1.nullable)(receipt_1.rpcTransactionReceipt), (tx) => tx?.blockNumber ?? undefined);
+    }
+    async getLogs(options) {
+        let address;
+        if (options.address !== undefined) {
+            address = Array.isArray(options.address)
+                ? options.address.map((x) => (0, ethereumjs_util_1.bufferToHex)(x))
+                : (0, ethereumjs_util_1.bufferToHex)(options.address);
+        }
+        let topics;
+        if (options.topics !== undefined) {
+            topics = options.topics.map((items) => items !== null
+                ? items.map((x) => (x !== null ? (0, ethereumjs_util_1.bufferToHex)(x) : x))
+                : null);
+        }
+        return this._perform("eth_getLogs", [
+            {
+                fromBlock: (0, base_types_1.numberToRpcQuantity)(options.fromBlock),
+                toBlock: (0, base_types_1.numberToRpcQuantity)(options.toBlock),
+                address,
+                topics,
+            },
+        ], t.array(log_1.rpcLog, "RpcLog Array"), () => options.toBlock);
+    }
+    async getAccountData(address, blockNumber) {
+        const results = await this._performBatch([
+            {
+                method: "eth_getCode",
+                params: [address.toString(), (0, base_types_1.numberToRpcQuantity)(blockNumber)],
+                tType: base_types_1.rpcData,
+            },
+            {
+                method: "eth_getTransactionCount",
+                params: [address.toString(), (0, base_types_1.numberToRpcQuantity)(blockNumber)],
+                tType: base_types_1.rpcQuantity,
+            },
+            {
+                method: "eth_getBalance",
+                params: [address.toString(), (0, base_types_1.numberToRpcQuantity)(blockNumber)],
+                tType: base_types_1.rpcQuantity,
+            },
+        ], () => blockNumber);
+        return {
+            code: results[0],
+            transactionCount: results[1],
+            balance: results[2],
+        };
+    }
+    // This is part of a temporary fix to https://github.com/NomicFoundation/hardhat/issues/2380
+    // This method caches each request instead of caching each block's fee info individually, which is not ideal
+    async getFeeHistory(blockCount, newestBlock, rewardPercentiles) {
+        return this._perform("eth_feeHistory", [
+            (0, base_types_1.numberToRpcQuantity)(blockCount),
+            newestBlock === "pending"
+                ? "pending"
+                : (0, base_types_1.numberToRpcQuantity)(newestBlock),
+            rewardPercentiles,
+        ], t.type({
+            oldestBlock: base_types_1.rpcQuantity,
+            baseFeePerGas: t.array(base_types_1.rpcQuantity),
+            gasUsedRatio: t.array(t.number),
+            reward: (0, io_ts_1.optional)(t.array(t.array(base_types_1.rpcQuantity))),
+        }), (res) => res.oldestBlock + BigInt(res.baseFeePerGas.length));
+    }
+    async getLatestBlockNumber() {
+        return this._perform("eth_blockNumber", [], base_types_1.rpcQuantity, (blockNumber) => blockNumber);
+    }
+    async _perform(method, params, tType, getMaxAffectedBlockNumber) {
+        const cacheKey = this._getCacheKey(method, params);
+        const cachedResult = this._getFromCache(cacheKey);
+        if (cachedResult !== undefined) {
+            return cachedResult;
+        }
+        if (this._forkCachePath !== undefined) {
+            const diskCachedResult = await this._getFromDiskCache(this._forkCachePath, cacheKey, tType);
+            if (diskCachedResult !== undefined) {
+                this._storeInCache(cacheKey, diskCachedResult);
+                return diskCachedResult;
+            }
+        }
+        const rawResult = await this._send(method, params);
+        const decodedResult = (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(rawResult, tType);
+        const blockNumber = getMaxAffectedBlockNumber(decodedResult);
+        if (this._canBeCached(blockNumber)) {
+            this._storeInCache(cacheKey, decodedResult);
+            if (this._forkCachePath !== undefined) {
+                await this._storeInDiskCache(this._forkCachePath, cacheKey, rawResult);
+            }
+        }
+        return decodedResult;
+    }
+    async _performBatch(batch, getMaxAffectedBlockNumber) {
+        // Perform Batch caches the entire batch at once.
+        // It could implement something more clever, like caching per request
+        // but it's only used in one place, and those other requests aren't
+        // used anywhere else.
+        const cacheKey = this._getBatchCacheKey(batch);
+        const cachedResult = this._getFromCache(cacheKey);
+        if (cachedResult !== undefined) {
+            return cachedResult;
+        }
+        if (this._forkCachePath !== undefined) {
+            const diskCachedResult = await this._getBatchFromDiskCache(this._forkCachePath, cacheKey, batch.map((b) => b.tType));
+            if (diskCachedResult !== undefined) {
+                this._storeInCache(cacheKey, diskCachedResult);
+                return diskCachedResult;
+            }
+        }
+        const rawResults = await this._sendBatch(batch);
+        const decodedResults = rawResults.map((result, i) => (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(result, batch[i].tType));
+        const blockNumber = getMaxAffectedBlockNumber(decodedResults);
+        if (this._canBeCached(blockNumber)) {
+            this._storeInCache(cacheKey, decodedResults);
+            if (this._forkCachePath !== undefined) {
+                await this._storeInDiskCache(this._forkCachePath, cacheKey, rawResults);
+            }
+        }
+        return decodedResults;
+    }
+    async _send(method, params, isRetryCall = false) {
+        try {
+            return await this._httpProvider.request({ method, params });
+        }
+        catch (err) {
+            if (this._shouldRetry(isRetryCall, err)) {
+                return this._send(method, params, true);
+            }
+            // This is a workaround for this TurboGeth bug: https://github.com/ledgerwatch/turbo-geth/issues/1645
+            if (err.code === -32000 && err.message.includes("not found")) {
+                return null;
+            }
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw err;
+        }
+    }
+    async _sendBatch(batch, isRetryCall = false) {
+        try {
+            return await this._httpProvider.sendBatch(batch);
+        }
+        catch (err) {
+            if (this._shouldRetry(isRetryCall, err)) {
+                return this._sendBatch(batch, true);
+            }
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw err;
+        }
+    }
+    _shouldRetry(isRetryCall, err) {
+        const isRetriableError = err.message.includes("header not found") ||
+            err.message.includes("connect ETIMEDOUT");
+        const isServiceUrl = this._httpProvider.url.includes("infura") ||
+            this._httpProvider.url.includes("alchemyapi");
+        return (!isRetryCall && isServiceUrl && err instanceof Error && isRetriableError);
+    }
+    _getCacheKey(method, params) {
+        const networkId = this.getNetworkId();
+        const plaintextKey = `${networkId} ${method} ${JSON.stringify(params)}`;
+        const hashed = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(plaintextKey, "utf8"));
+        return hashed.toString("hex");
+    }
+    _getBatchCacheKey(batch) {
+        let fakeMethod = "";
+        const fakeParams = [];
+        for (const entry of batch) {
+            fakeMethod += entry.method;
+            fakeParams.push(...entry.params);
+        }
+        return this._getCacheKey(fakeMethod, fakeParams);
+    }
+    _getFromCache(cacheKey) {
+        return this._cache.get(cacheKey);
+    }
+    _storeInCache(cacheKey, decodedResult) {
+        this._cache.set(cacheKey, decodedResult);
+    }
+    async _getFromDiskCache(forkCachePath, cacheKey, tType) {
+        const rawResult = await this._getRawFromDiskCache(forkCachePath, cacheKey);
+        if (rawResult !== undefined) {
+            return (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(rawResult, tType);
+        }
+    }
+    async _getBatchFromDiskCache(forkCachePath, cacheKey, tTypes) {
+        const rawResults = await this._getRawFromDiskCache(forkCachePath, cacheKey);
+        if (!Array.isArray(rawResults)) {
+            return undefined;
+        }
+        return rawResults.map((r, i) => (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(r, tTypes[i]));
+    }
+    async _getRawFromDiskCache(forkCachePath, cacheKey) {
+        try {
+            return await fs_extra_1.default.readJSON(this._getDiskCachePathForKey(forkCachePath, cacheKey), {
+                encoding: "utf8",
+            });
+        }
+        catch (error) {
+            if (error.code === "ENOENT") {
+                return undefined;
+            }
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw error;
+        }
+    }
+    async _storeInDiskCache(forkCachePath, cacheKey, rawResult) {
+        const requestPath = this._getDiskCachePathForKey(forkCachePath, cacheKey);
+        await fs_extra_1.default.ensureDir(path_1.default.dirname(requestPath));
+        await fs_extra_1.default.writeJSON(requestPath, rawResult, {
+            encoding: "utf8",
+        });
+    }
+    _getDiskCachePathForKey(forkCachePath, key) {
+        return path_1.default.join(forkCachePath, `network-${this._networkId}`, `request-${key}.json`);
+    }
+    _canBeCached(blockNumber) {
+        if (blockNumber === undefined) {
+            return false;
+        }
+        return !this._canBeReorgedOut(blockNumber);
+    }
+    _canBeReorgedOut(blockNumber) {
+        const maxSafeBlockNumber = this._latestBlockNumberOnCreation - this._maxReorg;
+        return blockNumber > maxSafeBlockNumber;
+    }
+}
+exports.JsonRpcClient = JsonRpcClient;
+//# sourceMappingURL=client.js.map
\ No newline at end of file
