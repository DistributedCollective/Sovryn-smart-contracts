const { expect } = require("chai");
const { network } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

const { expectRevert, expectEvent, BN } = require("@openzeppelin/test-helpers");

const { address, mineBlock, blockNumber } = require("../Utils/Ethereum");

const EIP712 = require("../Utils/EIP712");
// const EIP712Ethers = require("../Utils/EIP712Ethers");
const { getAccountsPrivateKeysBuffer } = require("../Utils/hardhat_utils");
const { deployAndGetIStaking } = require("../Utils/initializer");
const { ZERO_ADDRESS } = require("@openzeppelin/test-helpers/src/constants");

const StakingProxy = artifacts.require("StakingProxy");
const TestToken = artifacts.require("TestToken");
const VestingLogic = artifacts.require("VestingLogic");
//Upgradable Vesting Registry
const VestingRegistryLogic = artifacts.require("VestingRegistryLogic");
const VestingRegistryProxy = artifacts.require("VestingRegistryProxy");

const TOTAL_SUPPLY = "10000000000000000000000000";
const DELAY = 86400 * 14;
const TWO_WEEKS = 86400 * 14;

contract("Staking", (accounts) => {
    const name = "Test token";
    const symbol = "TST";

    let root, a1, a2, a3, chainId;
    let rootSigner, a1Signer;

    let token, staking;
    let MAX_VOTING_WEIGHT;

    let kickoffTS, inThreeYears;

    let vestingLogic1, vestingLogic2;

    let timestamp0, timestamp1, timestamp2;
    let stakeA,
        stakeB,
        totalStake,
        expectedVotingPower,
        expectedVotingPowerT1,
        expectedVotingPowerT2;

    // tool for debugging promises
    let debugPromise = (name, p) => p;
    // Uncomment for more debugging
    /*
    debugPromise = (name, p) => (
        p
            .then((r) => {
                console.log(`${name} mined in ${r.receipt.blockNumber}`);
                return r;
            })
            .catch((e) => {
                console.log(name, "failed\n", e);
                throw e;
            })
    );
    */

    async function deploymentAndInitFixture(_wallets, _provider) {
        chainId = 1; // await web3.eth.net.getId(); See: https://github.com/trufflesuite/ganache-core/issues/515
        await web3.eth.net.getId();
        token = await TestToken.new(name, symbol, 18, TOTAL_SUPPLY);

        /// Staking Modules
        // Creating the Staking Instance (Staking Modules Interface).
        const stakingProxy = await StakingProxy.new(token.address);
        staking = await deployAndGetIStaking(stakingProxy.address);

        //Upgradable Vesting Registry
        vestingRegistryLogic = await VestingRegistryLogic.new();
        vesting = await VestingRegistryProxy.new();
        await vesting.setImplementation(vestingRegistryLogic.address);
        vesting = await VestingRegistryLogic.at(vesting.address);

        await staking.setVestingRegistry(vesting.address);

        MAX_VOTING_WEIGHT = await staking.getStorageMaxVotingWeight.call();

        kickoffTS = await staking.kickoffTS.call();
        inThreeYears = kickoffTS.add(new BN(DELAY * 26 * 3));
    }

    before(async () => {
        [root, a1, a2, a3, ...accounts] = accounts;
        [rootSigner, a1Signer] = await ethers.getSigners();

        vestingLogic1 = await VestingLogic.new();
        vestingLogic2 = await VestingLogic.new();
    });

    beforeEach(async () => {
        await loadFixture(deploymentAndInitFixture);

        // last 3 timestamps must be a groupshot or exploit risks negative yield
        timestamp0 = kickoffTS.add(new BN(TWO_WEEKS * 42));
        timestamp1 = kickoffTS.add(new BN(TWO_WEEKS * 54));
        timestamp2 = kickoffTS.add(new BN(TWO_WEEKS * 56));
        //timestamp3 = kickoffTS.add(new BN(TWO_WEEKS * 56));

        stakeA = 1;
        stakeB = 9999;
        totalStake = stakeA + stakeB; // if != 10k adjust expected VP beloow
        expectedVotingPowerT1 = "35000"; // pre-calculated (with first test) for 10k staked until T1
        expectedVotingPowerT2 = "39000"; // pre-calculated (with first test) for 10k staked until T2
        expectedVotingPower = expectedVotingPowerT1;

        await token.transfer(a1, totalStake);
        await token.approve(staking.address, totalStake, { from: a1 });

        // exploit setup
        await staking.stake(stakeA, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, { from: a1 });
        await mineBlock();
    });

    afterEach(async () => {
        // Make sure we don't accidentally leave interval mining on after the tests
        await network.provider.send("evm_setAutomine", [true]);
        await network.provider.send("evm_setIntervalMining", [0]);
    });

    describe("Voting Power shaking exploit", () => {
        it("stakers get voting power proportional to tokens staked and stake duration", async () => {
            // This is the null case, no exploit here
            await staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, { from: a1 });

            await mineBlock();

            const checkedBlockNumber = new BN((await blockNumber()) - 1);

            expect(
                (await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()
            ).to.equal(expectedVotingPowerT1);
            expect(
                (
                    await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, {
                        from: a1,
                    })
                ).toString()
            ).to.equal(expectedVotingPowerT1);
            expect(
                (
                    await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)
                ).toString()
            ).to.equal(expectedVotingPowerT1);
        });

        it("forbids delegation in the same block as staking", async () => {
            let initBlock = await blockNumber();
            await network.provider.send("evm_setAutomine", [false]);

            const promises = [
                debugPromise(
                    "stake",
                    staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                    })
                ),
                debugPromise(
                    "delegate",
                    staking.delegate(a1, timestamp1, { from: a1, gas: 200000 })
                ),
            ];

            // mine all pending txs above (which are waiting in the mempool)
            await network.provider.send("evm_setIntervalMining", [1000]);
            let error = "";
            try {
                await Promise.all(promises);
            } catch (e) {
                error = e;
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }
            expect(error).not.to.equal("");

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);
        });

        it("forbids extension in the same block as staking", async () => {
            let initBlock = await blockNumber();
            await network.provider.send("evm_setAutomine", [false]);

            const promises = [
                debugPromise(
                    "stake",
                    staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                    })
                ),
                debugPromise(
                    "extend",
                    staking.extendStakingDuration(timestamp1, timestamp2, {
                        from: a1,
                        gas: 500000,
                    })
                ),
            ];

            // mine all pending txs above (which are waiting in the mempool)
            await network.provider.send("evm_setIntervalMining", [3000]);
            let error = "";
            try {
                await Promise.all(promises);
            } catch (e) {
                error = e;
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }
            expect(error).not.to.equal("");

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);
        });

        it("forbids withdrawal in the same block as staking", async () => {
            let initBlock = await blockNumber();

            await network.provider.send("evm_setAutomine", [false]);
            await network.provider.send("evm_setIntervalMining", [0]);

            const promises = [
                debugPromise(
                    "stake",
                    staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                    })
                ),
                debugPromise(
                    "withdraw",
                    staking.withdraw(1, timestamp1, a1, { from: a1, gas: 800000 })
                ),
            ];

            // mine all pending txs above (which are waiting in the mempool)
            await network.provider.send("evm_setIntervalMining", [1000]);
            let error = "";
            try {
                await Promise.all(promises);
            } catch (e) {
                error = e;
            }
            expect(error).not.to.equal("");

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);
        });

        it("sustains shaking in a single block", async () => {
            let initBlock = await blockNumber();

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            const promises = [
                debugPromise(
                    "1st",
                    staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                    })
                ),

                debugPromise(
                    "2nd",
                    staking.extendStakingDuration(timestamp1, timestamp2, {
                        from: a1,
                        gas: 400000,
                    })
                ),
                // continue shaking
                debugPromise("3rd", staking.delegate(a1, timestamp1, { from: a1, gas: 200000 })),
            ];

            // mine all pending txs above (which are waiting in the mempool)
            await network.provider.send("evm_setIntervalMining", [1000]);
            try {
                await Promise.all(promises);
            } catch (e) {
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);

            // mine a block, needed
            await mineBlock();

            const checkedBlockNumber = new BN((await blockNumber()) - 1);

            expect(
                (await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, {
                        from: a1,
                    })
                ).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)
                ).toString()
            ).to.equal(expectedVotingPower);
        });

        it("sustains delegationless shaking in a single block", async () => {
            await staking.stake(1000, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, { from: a1 });
            let initBlock = await blockNumber();

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            const promises = [
                debugPromise(
                    "1st",
                    staking.stake(stakeB - 1000, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                    })
                ),
                debugPromise(
                    "2nd",
                    staking.extendStakingDuration(timestamp1, timestamp2, {
                        from: a1,
                        gas: 400000,
                    })
                ),
                debugPromise(
                    "3rd",
                    staking.extendStakingDuration(timestamp1, timestamp2, {
                        from: a1,
                        gas: 400000,
                    })
                ),
            ];

            // reactivate mining
            await network.provider.send("evm_setIntervalMining", [1000]);

            // mine all pending txs above (which are waiting in the mempool)
            try {
                await Promise.all(promises);
            } catch (e) {
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);

            // Mine a block -- needed
            await mineBlock();

            const checkedBlockNumber = new BN((await blockNumber()) - 1);

            //console.log("measure for t1 at block# :", await blockNumber() );
            expect(
                (await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, {
                        from: a1,
                    })
                ).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)
                ).toString()
            ).to.equal(expectedVotingPower);
        });

        it("sustains shaking in a single block (and loop)", async () => {
            let initBlock = await blockNumber();

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);

            let nonce = await web3.eth.getTransactionCount(a1);

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            const promises = [
                debugPromise(
                    "stake",
                    staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, {
                        from: a1,
                        gas: 250000,
                        nonce: nonce++,
                    })
                ),
            ];
            // loop to skyrocket VP
            for (let i = 0; i < 8; i++) {
                promises.push(
                    debugPromise(
                        `extend${i}`,
                        staking.extendStakingDuration(timestamp1, timestamp2, {
                            from: a1,
                            gas: 350000,
                            nonce: nonce++,
                        })
                    )
                );
                promises.push(
                    debugPromise(
                        `delegate${i}`,
                        staking.delegate(a1, timestamp1, { from: a1, gas: 200000, nonce: nonce++ })
                    )
                );
            }

            // Mine the above transactions
            await network.provider.send("evm_setIntervalMining", [1000]);
            try {
                await Promise.all(promises);
            } catch (e) {
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }

            // Reactivate automining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            expect(exploitBlock).to.equal(initBlock + 1);

            // Mine a block -- needed
            await mineBlock();

            const checkedBlockNumber = new BN((await blockNumber()) - 1);

            expect(
                (await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, {
                        from: a1,
                    })
                ).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)
                ).toString()
            ).to.equal(expectedVotingPower);
        });

        it("sustains shaking without staking in the same block", async () => {
            await staking.stake(
                stakeB - stakeA,
                timestamp1.sub(new BN(TWO_WEEKS)),
                ZERO_ADDRESS,
                ZERO_ADDRESS,
                { from: a1 }
            ); //also works with a1 instead of zero, but this way is cheaper.
            await mineBlock();
            await staking.stake(stakeA, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, { from: a1 }); //also works with a1 instead of zero, but this way is cheaper.

            let initBlock = await blockNumber();

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            let nonce = await web3.eth.getTransactionCount(a1);
            const promises = [
                //do not stake, but instead extend until t1 from an older stake
                //debugPromise("stake", staking.stake(stakeB, timestamp1, ZERO_ADDRESS, ZERO_ADDRESS, { from: a1, gas: 250000, nonce: nonce++ })),
                debugPromise(
                    "t1-2w: extend to t1",
                    staking.extendStakingDuration(timestamp1.sub(new BN(TWO_WEEKS)), timestamp1, {
                        from: a1,
                        gas: 400000,
                        nonce: nonce++,
                    })
                ),
            ];

            for (let i = 0; i < 5; i++) {
                promises.push(
                    debugPromise(
                        `t1: extend to t2   (round ${i + 1})`,
                        staking.extendStakingDuration(timestamp1, timestamp2, {
                            from: a1,
                            gas: 250000,
                            nonce: nonce++,
                        })
                    ),

                    debugPromise(
                        `t1: delegate to a1 (round ${i + 1})`,
                        staking.delegate(a1, timestamp1, { from: a1, gas: 100000, nonce: nonce++ })
                    )
                );
            }

            await network.provider.send("evm_setIntervalMining", [1000]);

            let error = "";
            try {
                await Promise.all(promises);
            } catch (e) {
                error = e;
                // Some promise failed -- it is expected, no need to know which unless debugging
                // To check which tx failed, uncomment debugPromise debug code L48-58
            }
            //expect(error).not.to.equal("");

            // Re-enable mining
            await network.provider.send("evm_setAutomine", [true]);
            await network.provider.send("evm_setIntervalMining", [0]);

            let exploitBlock = await blockNumber();
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock + 1);

            // mine a block, needed
            await mineBlock();

            const checkedBlockNumber = new BN((await blockNumber()) - 1);

            expect(
                (await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, {
                        from: a1,
                    })
                ).toString()
            ).to.equal(expectedVotingPower);

            expect(
                (
                    await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)
                ).toString()
            ).to.equal(expectedVotingPower);
        });
    });
});
