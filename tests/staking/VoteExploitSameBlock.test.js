const { expect } = require("chai");
const { waffle, network } = require("hardhat");
const { loadFixture } = waffle;

const { expectRevert, expectEvent, BN } = require("@openzeppelin/test-helpers");

const { address, mineBlock, blockNumber } = require("../Utils/Ethereum");

const EIP712 = require("../Utils/EIP712");
// const EIP712Ethers = require("../Utils/EIP712Ethers");
const { getAccountsPrivateKeysBuffer } = require("../Utils/hardhat_utils");

const StakingLogic = artifacts.require("StakingMockup");
const StakingProxy = artifacts.require("StakingProxy");
const TestToken = artifacts.require("TestToken");
const VestingLogic = artifacts.require("VestingLogic");
//Upgradable Vesting Registry
const VestingRegistryLogic = artifacts.require("VestingRegistryLogic");
const VestingRegistryProxy = artifacts.require("VestingRegistryProxy");

const TOTAL_SUPPLY = "10000000000000000000000000";
const DELAY = 86400 * 14;
const TWO_WEEKS = 86400 * 14;

contract("Staking", (accounts) => {
	const name = "Test token";
	const symbol = "TST";

	const addr_zero = address(0);

	let root, a1, a2, a3, chainId;
	let rootSigner, a1Signer;

	let token, staking;
	let MAX_VOTING_WEIGHT;

	let kickoffTS, inThreeYears;

	let vestingLogic1, vestingLogic2;

	let timestamp0, timestamp1, timestamp2;
	let stakeA, stakeB, totalStake;

	// tool for debugging promises
	let debugPromise = (name, p) => p;
	// Uncomment for more debugging
	//debugPromise = (name, p) => (
	//	p
	//		.then((r) => {
	//			console.log(`${name} mined in ${r.receipt.blockNumber}`);
	//			return r;
	//		})
	//		.catch((e) => {
	//			console.log(name, "failed\n", e);
	//			throw e;
	//		})
	//);

	async function deploymentAndInitFixture(_wallets, _provider) {
		chainId = 1; // await web3.eth.net.getId(); See: https://github.com/trufflesuite/ganache-core/issues/515
		await web3.eth.net.getId();
		token = await TestToken.new(name, symbol, 18, TOTAL_SUPPLY);

		let stakingLogic = await StakingLogic.new(token.address);
		staking = await StakingProxy.new(token.address);
		await staking.setImplementation(stakingLogic.address);
		staking = await StakingLogic.at(staking.address);
		//Upgradable Vesting Registry
		vestingRegistryLogic = await VestingRegistryLogic.new();
		vesting = await VestingRegistryProxy.new();
		await vesting.setImplementation(vestingRegistryLogic.address);
		vesting = await VestingRegistryLogic.at(vesting.address);

		await staking.setVestingRegistry(vesting.address);

		MAX_VOTING_WEIGHT = await staking.MAX_VOTING_WEIGHT.call();

		kickoffTS = await staking.kickoffTS.call();
		inThreeYears = kickoffTS.add(new BN(DELAY * 26 * 3));
	}

	before(async () => {
		[root, a1, a2, a3, ...accounts] = accounts;
		[rootSigner, a1Signer] = await ethers.getSigners();

		vestingLogic1 = await VestingLogic.new();
		vestingLogic2 = await VestingLogic.new();
	});

	beforeEach(async () => {
		await loadFixture(deploymentAndInitFixture);

		// last 3 timestamps must be a groupshot or exploit risks negative yield
		timestamp0 = kickoffTS.add(new BN(TWO_WEEKS * 42));
		timestamp1 = kickoffTS.add(new BN(TWO_WEEKS * 54));
		timestamp2 = kickoffTS.add(new BN(TWO_WEEKS * 56));
		//timestamp3 = kickoffTS.add(new BN(TWO_WEEKS * 56));

		stakeA = 1;
		stakeB = 9999;
		totalStake = stakeA + stakeB; // if != 10k adjust hardcoded weightedPower function

		await token.transfer(a1, totalStake + 1);
		await token.approve(staking.address, totalStake, { from: a1 });
		await mineBlock();
	});

	describe("Voting Power shaking exploit", () => {
		it("stakers get voting power proportional to tokens staked and stake duration", async () => {
			await staking.stake(totalStake, timestamp2, addr_zero, addr_zero, { from: a1 });

			await mineBlock();
			await mineBlock();

			expect((await staking.getPriorVotes.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);
			expect(
				(await staking.getPriorTotalVotingPower.call(new BN((await blockNumber()) - 1), timestamp0, { from: a1 })).toString()
			).to.equal(weightedPower(totalStake).toString());
			expect((await staking.getPriorWeightedStake.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);
		});

		it("sustains shaking in a single block", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });

			let initBlock = await blockNumber();
			//console.log("initBlock", initBlock.toString());
			//console.log("first stake block# :", initBlock );

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			//console.log("before queuing shaking promises");
			const promises = [
				debugPromise(
					'1st',
					staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 })
				),
				debugPromise(
					'2nd',
					staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 })
				),
				// continue shaking
				debugPromise(
					'4th',
					staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000 })
				),
			];
			//console.log("after queuing shaking promises");

			// reactivate mining
			//console.log("before evm_setIntervalMining");
			await network.provider.send("evm_setIntervalMining", [1000]);
			//console.log("after evm_setIntervalMining");
			try {
				await Promise.all(promises);
			} catch(e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			// Re-enable mining
			await network.provider.send("evm_setAutomine", [true]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// mine all pending txs above (which are waiting in the mempool)
			let exploitBlock = await blockNumber();
			//console.log("exploitBlock", exploitBlock.toString());
			//console.log("exploit block# :", exploitBlock );
			// fails test if exploit does not fit in single block
			expect(exploitBlock).to.equal(initBlock + 1);

			//await Promise.all(promises)

			// extend leftover stake (A) from t1 to t3
			// canary tx, if it is mined, exploit is mined (in previous block)
			//console.log("before canary tx");
			try {
				await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
			} catch(e) {
				// TODO: figure out this error and remove warning
				console.warn('extendStakingDuration failed. is this intended?');
			}
			//console.log(`after canary tx (mined in block ${tx.receipt.blockNumber})`);
			//console.log("canary tx mined at block#", tx.receipt.blockNumber );

			// last strong shake
			// another unexplained booster
			//console.log("before last strong shake");
			try {
				await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
			} catch (e) {
				// TODO: figure out this error and remove warning
				console.warn('extendStakingDuration failed. is this intended?');
			}
			//console.log(`after last strong shake (mined in block ${tx.receipt.blockNumber})`);

			await mineBlock();
			await mineBlock();

			//console.log("measure for t1 at block# :", await blockNumber() );
			expect((await staking.getPriorVotes.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);

			expect(
				(await staking.getPriorTotalVotingPower.call(new BN((await blockNumber()) - 1), timestamp0, { from: a1 })).toString()
			).to.equal(weightedPower(totalStake).toString());

			expect((await staking.getPriorWeightedStake.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);
		});

		it("sustains delegationless shaking in a single block", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });
			await mineBlock();
			//console.log(
			//	"VP after stakeA",
			//	staking.getPriorTotalVotingPower.call(new BN((await blockNumber()) - 1), timestamp0, { from: a1 })
			//);
			let initBlock = await blockNumber();
			//console.log("initBlock", initBlock.toString());
			//console.log("first stake block# :", initBlock );

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			//console.log("before queuing shaking promises");
			const promises = [
				debugPromise(
					'1st',
					staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 })
				),
				debugPromise(
					'2nd',
					 staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 })
				)
			];

			// reactivate mining
			await network.provider.send("evm_setIntervalMining", [1000]);
			//console.log("after evm_setIntervalMining");

			// mine all pending txs above (which are waiting in the mempool)
			try {
				await Promise.all(promises)
			} catch(e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			//await mineBlock(); // no need to mine here

			let exploitBlock = await blockNumber();
			//console.log("exploitBlock", exploitBlock.toString());
			//console.log("exploit block# :", exploitBlock );
			// fails test if exploit does not fit in single block
			expect(exploitBlock).to.equal(initBlock + 1);

			// extend leftover stake (A) from t1 to t2
			// canary tx, if it is mined, exploit is mined (in previous block)
			//console.log('before canary tx');
			let tx = await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
			//console.log(`after canary tx (mined in block ${tx.receipt.blockNumber})`);
			//console.log("canary tx mined at block#", tx.receipt.blockNumber );

			await mineBlock();
			//console.log(
			//	"VP after exploit block",
			//staking.getPriorTotalVotingPower.call(new BN((await blockNumber()) - 1), timestamp0, { from: a1 })
			//	);

			// last strong shake
			// another unexplained booster
			//console.log('before last strong shake');
			try {
				// TODO: I'm not sure why this will fail -- it's not in the same block!?
				await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
			} catch (e) {
				// TODO: figure out this error and remove warning
				console.warn('extendStakingDuration failed. is this intended?');
			}
			//console.log(`after last strong shake (mined in block ${tx.receipt.blockNumber})`);

			await mineBlock();

			//console.log("measure for t1 at block# :", await blockNumber() );
			expect((await staking.getPriorVotes.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);

			expect(
				(await staking.getPriorTotalVotingPower.call(new BN((await blockNumber()) - 1), timestamp0, { from: a1 })).toString()
			).to.equal(weightedPower(totalStake).toString());

			expect((await staking.getPriorWeightedStake.call(a1, new BN((await blockNumber()) - 1), timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);
		});

		it("sustains shaking in a single block (and loop): will fail", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });

			let initBlock = await blockNumber();

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			let nonce = await web3.eth.getTransactionCount(a1);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			const promises = [
				debugPromise(
					"stake",
					staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000, nonce: nonce++ })
				),
				debugPromise(
					"first extend",
					staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000, nonce: nonce++ })
				),
				//debugPromise('first delegate', staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000, nonce: nonce++ })),
				//debugPromise('canary extend', staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000, nonce: nonce++ })),
			];
			// loop to skyrocket VP
			for (let i = 0; i < 8; i++) {
				promises.push(
					debugPromise(`delegate${i}`, staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000, nonce: nonce++ }))
				);
				promises.push(
					debugPromise(
						`extend${i}`,
						staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 350_000, nonce: nonce++ })
					)
				);
			}

			// Mine the above transactions
			await network.provider.send("evm_setIntervalMining", [1000]);
			try {
				await Promise.all(promises);
			} catch (e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			// Reactivate automining
			await network.provider.send("evm_setAutomine", [true]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// mine all pending txs above (which are waiting in the mempool)
			let exploitBlock = await blockNumber();
			//console.log("exploitBlock", exploitBlock.toString());
			expect(exploitBlock).to.equal(initBlock + 1);

			// killing blow : delegate
			await staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000 });
			await staking.delegate(a1, timestamp2, { from: a1, gasLimit: 200_000 });

			// Mine a single block, this seems to be needed
			await mineBlock();

			const checkedBlockNumber = exploitBlock;

			expect((await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);

			expect((await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, { from: a1 })).toString()).to.equal(
				weightedPower(totalStake).toString()
			);

			expect((await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(
				weightedPower(totalStake).toString()
			);
		});
	});

	function weightedPower(stake) {
		//return weightingFunction(stake, now, maxDuration, MAX_VOTING_WEIGHT, weightFactor)
		return 39000; // temp value for this specific scenario when measured for t0 (totalStake=10k until t3)
	}

	function weightingFunction(stake, time, maxDuration, maxVotingWeight, weightFactor) {
		let x = maxDuration - time;
		let mD2 = maxDuration * maxDuration;
		return Math.floor((stake * (Math.floor((maxVotingWeight * weightFactor * (mD2 - x * x)) / mD2) + weightFactor)) / weightFactor);
	}
});
