{
  "address": "0xA6F8bE3759bABDB77c39D6E0752f82D46a8fEfE4",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RewardWithdrawn",
      "type": "event"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "BASE_RATE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "DIVISOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "TWO_WEEKS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_startTime",
          "type": "uint256"
        }
      ],
      "name": "collectReward",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "bool",
          "name": "_considerMaxDuration",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_startTime",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_staker",
          "type": "address"
        }
      ],
      "name": "getArbitraryStakerCurrentReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nextWithdrawTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getAverageBlockTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_checkpointTimestamp",
          "type": "uint256"
        }
      ],
      "name": "getCheckpointBlockNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getDeploymentBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getMaxDuration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getOsSOV",
      "outputs": [
        {
          "internalType": "contract IERC20Mintable",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getRewardsProgramStartTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "bool",
          "name": "_considerMaxDuration",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_startTime",
          "type": "uint256"
        }
      ],
      "name": "getStakerCurrentReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nextWithdrawTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "_staker",
          "type": "address"
        }
      ],
      "name": "getStakerNextWithdrawTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getStaking",
      "outputs": [
        {
          "internalType": "contract IStaking",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getStopBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "getStopRewardsTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "_osSOV",
          "type": "address"
        },
        {
          "internalType": "contract IStaking",
          "name": "_staking",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_averageBlockTime",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "isOwner",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_averageBlockTime",
          "type": "uint256"
        }
      ],
      "name": "setAverageBlockTime",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "setBlock",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_time",
          "type": "uint256"
        }
      ],
      "name": "setHistoricalBlock",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_duration",
          "type": "uint256"
        }
      ],
      "name": "setMaxDuration",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "stop",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa4e38ab743119101d20f9140cd6e90228f3fb967ebc967cc22273ba262585bde",
  "receipt": {
    "to": null,
    "from": "0x8C9143221F2b72Fcef391893c3a02Cf0fE84f50b",
    "contractAddress": "0xA6F8bE3759bABDB77c39D6E0752f82D46a8fEfE4",
    "transactionIndex": 0,
    "gasUsed": "1461099",
    "logsBloom": "0x00000000000000000000000000000000000000001000000000800000000000000000000000000000000000000000000080000000800000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000002800000000000000000000000000000000400000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbb333fce20c2aba6d1e9cc5230068f3b8ef8f6e374b5e5b1389e74f1c79f5d89",
    "transactionHash": "0xa4e38ab743119101d20f9140cd6e90228f3fb967ebc967cc22273ba262585bde",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 4842877,
        "transactionHash": "0xa4e38ab743119101d20f9140cd6e90228f3fb967ebc967cc22273ba262585bde",
        "address": "0xA6F8bE3759bABDB77c39D6E0752f82D46a8fEfE4",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000008c9143221f2b72fcef391893c3a02cf0fe84f50b"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xbb333fce20c2aba6d1e9cc5230068f3b8ef8f6e374b5e5b1389e74f1c79f5d89"
      }
    ],
    "blockNumber": 4842877,
    "cumulativeGasUsed": "1461099",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "fff63f863151350c652df943b3c6ea48",
  "metadata": "{\"compiler\":{\"version\":\"0.5.17+commit.d19bba13\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawn\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_WEEKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"collectReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_considerMaxDuration\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getArbitraryStakerCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextWithdrawTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAverageBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_checkpointTimestamp\",\"type\":\"uint256\"}],\"name\":\"getCheckpointBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeploymentBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOsSOV\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardsProgramStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_considerMaxDuration\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"getStakerCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextWithdrawTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerNextWithdrawTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStaking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStopBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStopRewardsTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_osSOV\",\"type\":\"address\"},{\"internalType\":\"contract IStaking\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_averageBlockTime\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_averageBlockTime\",\"type\":\"uint256\"}],\"name\":\"setAverageBlockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setHistoricalBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setMaxDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"collectReward(uint256)\":{\"details\":\"User calls this function to collect osSOV staking rewards accrued by this contract The weighted stake is calculated using getPriorWeightedStake. Block number sent to the functon must be a finalised block, hence we deduct 1 from the current block. User is only allowed to withdraw after intervals of 14 days.\",\"params\":{\"_startTime\":\"The time from which to start the staking rewards calculation The issue is that we can only run for a max duration and if someone stakes for the first time after the max duration is over, the reward will always return 0. Thus, we need to restart from the duration that elapsed without generating rewards.\"}},\"getArbitraryStakerCurrentReward(bool,uint256,address)\":{\"details\":\"getArbitraryStakerCurrentReward function internally calls this function to calculate reward amount\",\"params\":{\"_considerMaxDuration\":\"True: Runs for the maximum duration - used in tx not to run out of gas False - to query total rewards\",\"_staker\":\"The staker address to calculate rewards for\",\"_startTime\":\"The time from which the staking rewards calculation shall restart.\"},\"return\":\"The timestamp of last withdrawalThe accumulated reward\"},\"getCheckpointBlockNumber(uint256)\":{\"params\":{\"_checkpointTimestamp\":\"Checkpoint timestamp\"}},\"getStakerCurrentReward(bool,uint256)\":{\"details\":\"getStakerCurrentReward function internally calls this function to calculate reward amount of msg.sender\",\"params\":{\"_considerMaxDuration\":\"True: Runs for the maximum duration - used in tx not to run out of gas False - to query total rewards\",\"_startTime\":\"The time from which the staking rewards calculation shall restart.\"},\"return\":\"The timestamp of last withdrawalThe accumulated reward\"},\"initialize(address,address,uint256)\":{\"params\":{\"_averageBlockTime\":\"average block time used for calculating rewards\",\"_osSOV\":\"osSOV token address\",\"_staking\":\"StakingProxy address should be passed\"}},\"isOwner()\":{\"details\":\"Returns true if the caller is the current owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"setAverageBlockTime(uint256)\":{\"details\":\"If average block time significantly changes, we can update it here and use for block number calculation\",\"params\":{\"_averageBlockTime\":\"- average block time used for calculating checkpoint blocks\"}},\"setHistoricalBlock(uint256)\":{\"params\":{\"_time\":\"Exact staking checkpoint time\"}},\"setMaxDuration(uint256)\":{\"details\":\"Rewards can be collected for a maximum duration at a time. This is to avoid Block Gas Limit failures. Setting it zero would mean that it will loop through the entire duration since the start of rewards program. It should ideally be set to a value, for which the rewards can be easily processed.\",\"params\":{\"_duration\":\"Max duration for which rewards can be collected at a go (in seconds)\"}},\"stop()\":{\"details\":\"Users will only get rewards up to the stop block\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"Staking Rewards Contract.\"},\"userdoc\":{\"methods\":{\"collectReward(uint256)\":{\"notice\":\"Collect rewards\"},\"getArbitraryStakerCurrentReward(bool,uint256,address)\":{\"notice\":\"Get any staker's current accumulated reward\"},\"getStakerCurrentReward(bool,uint256)\":{\"notice\":\"Get staker's current accumulated reward\"},\"initialize(address,address,uint256)\":{\"notice\":\"Replacement of constructor by initialize function for Upgradable Contracts This function will be called only once by the owner.\"},\"setAverageBlockTime(uint256)\":{\"notice\":\"Changes average block time - based on blockchain\"},\"setBlock()\":{\"notice\":\"This function computes the last staking checkpoint and calculates the corresponding block number using the average block time which is then added to the mapping `checkpointBlockNumber`.\"},\"setHistoricalBlock(uint256)\":{\"notice\":\"This function computes the block number using the average block time for a given historical checkpoint which is added to the mapping `checkpointBlockNumber`.\"},\"setMaxDuration(uint256)\":{\"notice\":\"Sets the max duration\"},\"stop()\":{\"notice\":\"Stops the current rewards program.\"}},\"notice\":\"This is a trial incentive program. In this, the osSOV minted to voluntary stakers and is locked until transferred to BitcoinOS\"}},\"settings\":{\"compilationTarget\":{\"contracts/governance/StakingRewards/StakingRewardsOs.sol\":\"StakingRewardsOs\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":ds-test/=foundry/lib/forge-std/lib/ds-test/src/\",\":forge-std/=foundry/lib/forge-std/src/\"]},\"sources\":{\"contracts/governance/Staking/interfaces/IStaking.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Interface for Staking modules governance/Staking/modules\\n */\\n\\ninterface IStaking {\\n    /*************************** StakingAdminModule ***************************/\\n\\n    /**\\n     * @notice Add account to Admins ACL.\\n     * @param _admin The addresses of the account to grant permissions.\\n     * */\\n    function addAdmin(address _admin) external;\\n\\n    /**\\n     * @notice Remove account from Admins ACL.\\n     * @param _admin The addresses of the account to revoke permissions.\\n     * */\\n    function removeAdmin(address _admin) external;\\n\\n    /**\\n     * @notice Add account to pausers ACL.\\n     * @param _pauser The address to grant pauser permissions.\\n     * */\\n    function addPauser(address _pauser) external;\\n\\n    /**\\n     * @notice Remove account from pausers ACL.\\n     * @param _pauser The address to grant pauser permissions.\\n     * */\\n    function removePauser(address _pauser) external;\\n\\n    /**\\n     * @notice Pause/unpause contract\\n     * @param _pause true when pausing, false when unpausing\\n     * */\\n    function pauseUnpause(bool _pause) external;\\n\\n    /**\\n     * @notice Freeze contract - disable all functions\\n     * @param _freeze true when freezing, false when unfreezing\\n     * @dev When freezing, pause is always applied too. When unfreezing, the contract is left in paused stated.\\n     * */\\n    function freezeUnfreeze(bool _freeze) external;\\n\\n    /**\\n     * @notice Allows the owner to set a fee sharing proxy contract.\\n     * We need it for unstaking with slashing.\\n     * @param _feeSharing The address of FeeSharingCollectorProxy contract.\\n     * */\\n    function setFeeSharing(address _feeSharing) external;\\n\\n    /**\\n     * @notice Allow the owner to set weight scaling.\\n     * We need it for unstaking with slashing.\\n     * @param _weightScaling The weight scaling.\\n     * */\\n    function setWeightScaling(uint96 _weightScaling) external;\\n\\n    /**\\n     * @notice Allow the owner to set a new staking contract.\\n     * As a consequence it allows the stakers to migrate their positions\\n     * to the new contract.\\n     * @dev Doesn't have any influence as long as migrateToNewStakingContract\\n     * is not implemented.\\n     * @param _newStakingContract The address of the new staking contract.\\n     * */\\n    function setNewStakingContract(address _newStakingContract) external;\\n\\n    /**\\n     * @notice Allow a staker to migrate his positions to the new staking contract.\\n     * @dev Staking contract needs to be set before by the owner.\\n     * Currently not implemented, just needed for the interface.\\n     *      In case it's needed at some point in the future,\\n     *      the implementation needs to be changed first.\\n     * */\\n    function migrateToNewStakingContract() external; // dummy - not implemented as of now\\n\\n    /*************************** StakingGovernanceModule ***************************/\\n\\n    /**\\n     * @notice Compute the total voting power at a given time.\\n     * @param blockNumber The block number, needed for checkpointing.\\n     * @param time The timestamp for which to calculate the total voting power.\\n     * @return The total voting power at the given time.\\n     * */\\n    function getPriorTotalVotingPower(\\n        uint32 blockNumber,\\n        uint256 time\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Get the current votes balance for a user account.\\n     * @param account The address to get votes balance.\\n     * @dev This is a wrapper to simplify arguments. The actual computation is\\n     * performed on WeightedStaking parent contract.\\n     * @return The number of current votes for a user account.\\n     * */\\n    function getCurrentVotes(address account) external view returns (uint96);\\n\\n    /**\\n     * @notice Determine the prior number of votes for a delegatee as of a block number.\\n     * Iterate through checkpoints adding up voting power.\\n     * @dev Block number must be a finalized block or else this function will revert\\n     * to prevent misinformation.\\n     *      Used for Voting, not for fee sharing.\\n     * @param account The address of the account to check.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @param date The staking date to compute the power for.\\n     * @return The number of votes the delegatee had as of the given block.\\n     * */\\n    function getPriorVotes(\\n        address account,\\n        uint256 blockNumber,\\n        uint256 date\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Determine the prior number of stake for an account as of a block number.\\n     * @dev Block number must be a finalized block or else this function will\\n     * revert to prevent misinformation.\\n     * @param account The address of the account to check.\\n     * @param date The staking date to compute the power for.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @return The number of votes the account had as of the given block.\\n     * */\\n    function getPriorStakeByDateForDelegatee(\\n        address account,\\n        uint256 date,\\n        uint256 blockNumber\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Determine the prior number of stake for an unlocking date as of a block number.\\n     * @dev Block number must be a finalized block or else this function will\\n     * revert to prevent misinformation.\\n     * TODO: WeightedStaking::getPriorTotalStakesForDate should probably better\\n     * be internal instead of a public function.\\n     * @param date The date to check the stakes for.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @return The number of votes the account had as of the given block.\\n     * */\\n    function getPriorTotalStakesForDate(\\n        uint256 date,\\n        uint256 blockNumber\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`.\\n     * @param delegatee The address to delegate votes to.\\n     * @param lockDate the date if the position to delegate.\\n     * */\\n    function delegate(address delegatee, uint256 lockDate) external;\\n\\n    /*************************** StakingStakeModule ***************************/\\n\\n    event TokensStaked(\\n        address indexed staker,\\n        uint256 amount,\\n        uint256 lockedUntil,\\n        uint256 totalStaked\\n    );\\n\\n    /**\\n     * @notice Stake the given amount for the given duration of time.\\n     * @param amount The number of tokens to stake.\\n     * @param until Timestamp indicating the date until which to stake.\\n     * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\\n     * @param delegatee The address of the delegatee or 0x0 if there is none.\\n     * */\\n    function stake(uint96 amount, uint256 until, address stakeFor, address delegatee) external;\\n\\n    /**\\n     * @notice Stake the given amount for the given duration of time.\\n     * @dev This function will be invoked from receiveApproval\\n     * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeWithApproval\\n     * @param sender The sender of SOV.approveAndCall\\n     * @param amount The number of tokens to stake.\\n     * @param until Timestamp indicating the date until which to stake.\\n     * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\\n     * @param delegatee The address of the delegatee or 0x0 if there is none.\\n     * */\\n    function stakeWithApproval(\\n        address sender,\\n        uint96 amount,\\n        uint256 until,\\n        address stakeFor,\\n        address delegatee\\n    ) external;\\n\\n    /**\\n     * @notice Receives approval from SOV token.\\n     * @param _data The data will be used for low level call.\\n     */\\n    function receiveApproval(\\n        address _sender,\\n        uint256 _amount,\\n        address _token,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @notice Extend the staking duration until the specified date.\\n     * @param previousLock The old unlocking timestamp.\\n     * @param until The new unlocking timestamp in seconds.\\n     * */\\n    function extendStakingDuration(uint256 previousLock, uint256 until) external;\\n\\n    /**\\n     * @dev DO NOT USE this misspelled function. Use stakeBySchedule function instead.\\n     * This function cannot be deprecated while we have non-upgradeable vesting contracts.\\n     * */\\n    function stakesBySchedule(\\n        uint256 amount,\\n        uint256 cliff,\\n        uint256 duration,\\n        uint256 intervalLength,\\n        address stakeFor,\\n        address delegatee\\n    ) external;\\n\\n    /**\\n     * @notice Stake tokens according to the vesting schedule.\\n     * @param amount The amount of tokens to stake.\\n     * @param cliff The time interval to the first withdraw.\\n     * @param duration The staking duration.\\n     * @param intervalLength The length of each staking interval when cliff passed.\\n     * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\\n     * @param delegatee The address of the delegatee or 0x0 if there is none.\\n     * */\\n    function stakeBySchedule(\\n        uint256 amount,\\n        uint256 cliff,\\n        uint256 duration,\\n        uint256 intervalLength,\\n        address stakeFor,\\n        address delegatee\\n    ) external;\\n\\n    /**\\n     * @notice Get the number of staked tokens held by the user account.\\n     * @dev Iterate checkpoints adding up stakes.\\n     * @param account The address of the account to get the balance of.\\n     * @return The number of tokens held.\\n     * */\\n    function balanceOf(address account) external view returns (uint96 balance);\\n\\n    /**\\n     * @notice Get the current number of tokens staked for a day.\\n     * @param lockedTS The timestamp to get the staked tokens for.\\n     * */\\n    function getCurrentStakedUntil(uint256 lockedTS) external view returns (uint96);\\n\\n    /**\\n     * @notice Get list of stakes for a user account.\\n     * @param account The address to get stakes.\\n     * @return The arrays of dates and stakes.\\n     * */\\n    function getStakes(\\n        address account\\n    ) external view returns (uint256[] memory dates, uint96[] memory stakes);\\n\\n    /**\\n     * @notice Unstaking is possible every 2 weeks only. This means, to\\n     * calculate the key value for the staking checkpoints, we need to\\n     * map the intended timestamp to the closest available date.\\n     * @param timestamp The unlocking timestamp.\\n     * @return The actual unlocking date (might be up to 2 weeks shorter than intended).\\n     * */\\n    function timestampToLockDate(uint256 timestamp) external view returns (uint256);\\n\\n    /*************************** StakingStorageModule ***************************/\\n\\n    /// @notice The maximum duration to stake tokens\\n    /// @return MAX_DURATION to stake tokens\\n    function getStorageMaxDurationToStakeTokens() external pure returns (uint256);\\n\\n    /// @notice The maximum possible voting weight before adding +1 (actually 10, but need 9 for computation).\\n    /// @return uint256(MAX_VOTING_WEIGHT);\\n    function getStorageMaxVotingWeight() external pure returns (uint256);\\n\\n    /// @notice weight is multiplied with this factor (for allowing decimals, like 1.2x).\\n    /// @dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\\n    /// @return uint256(WEIGHT_FACTOR);\\n    function getStorageWeightFactor() external pure returns (uint256);\\n\\n    /// @return uint256(DEFAULT_WEIGHT_SCALING);\\n    function getStorageDefaultWeightScaling() external pure returns (uint256);\\n\\n    /// @notice return (uint256(MIN_WEIGHT_SCALING), uint256(MAX_WEIGHT_SCALING))\\n    function getStorageRangeForWeightScaling()\\n        external\\n        pure\\n        returns (uint256 minWeightScaling, uint256 maxWeightScaling);\\n\\n    /// @notice The EIP-712 typehash for the contract's domain.\\n    /// @return uint256(DOMAIN_TYPEHASH);\\n    function getStorageDomainTypehash() external pure returns (uint256);\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract.\\n    /// @return uint256(DELEGATION_TYPEHASH);\\n    function getStorageDelegationTypehash() external pure returns (uint256);\\n\\n    /// @return name;\\n    function getStorageName() external view returns (string memory);\\n\\n    /// AUTOGENERATED FUNCTIONS FROM THE STAKING STORAGE PUBLIC VARIABLES ///\\n\\n    /// @notice The timestamp of contract creation. Base for the staking period calculation.\\n    function kickoffTS() external view returns (uint256);\\n\\n    /// @notice The token to be staked\\n    function SOVToken() external view returns (address);\\n\\n    /// @notice Stakers delegated voting power\\n    /// @param staker - the delegating address\\n    /// @param until - delegated voting\\n    /// @return _delegate - voting power delegated to address\\n    function delegates(address staker, uint256 until) external view returns (address _delegate);\\n\\n    /// @notice If this flag is set to true, all tokens are unlocked immediately\\n    /// see function unlockAllTokens() for details\\n    function allUnlocked() external view returns (bool);\\n\\n    /// @notice Used for stake migrations to a new staking contract with a different storage structure\\n    function newStakingContract() external view returns (address);\\n\\n    /// CHECKPOINTS\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 stake;\\n    }\\n\\n    /// @notice A record of tokens to be unstaked at a given time in total.\\n    /// For total voting power computation. Voting weights get adjusted bi-weekly.\\n    /// @dev totalStakingCheckpoints[date][index] is a checkpoint\\n    function totalStakingCheckpoints(\\n        uint256 date,\\n        uint32 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @notice The number of total staking checkpoints for each date.\\n    /// @dev numTotalStakingCheckpoints[date] is a number.\\n    function numTotalStakingCheckpoints(\\n        uint256 date\\n    ) external view returns (uint32 checkpointsQty);\\n\\n    /// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address.\\n    /// For delegatee voting power computation. Voting weights get adjusted bi-weekly.\\n    /// @dev delegateStakingCheckpoints[delegatee][date][index] is a checkpoint.\\n    function delegateStakingCheckpoints(\\n        address delagatee,\\n        uint256 date,\\n        uint32 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @notice The number of total staking checkpoints for each date per delegate.\\n    /// @dev numDelegateStakingCheckpoints[delegatee][date] is a number.\\n    function numDelegateStakingCheckpoints(\\n        address delegatee,\\n        uint256 date\\n    ) external view returns (uint32 checkpointsQty);\\n\\n    /// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\\n    /// @dev userStakingCheckpoints[user][date][index] is a checkpoint.\\n    function userStakingCheckpoints(\\n        address user,\\n        uint256 date,\\n        uint32 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @notice The number of total staking checkpoints for each date per user.\\n    /// @dev numUserStakingCheckpoints[user][date] is a number\\n    function numUserStakingCheckpoints(\\n        address user,\\n        uint256 date\\n    ) external view returns (uint32 checkpointsQty);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    /// @dev nonces[user] is a number.\\n    function nonces(address user) external view returns (uint256 nonce);\\n\\n    /// SLASHING ///\\n\\n    /// @notice the address of FeeSharingCollectorProxy contract, we need it for unstaking with slashing.\\n    function feeSharing() external view returns (address);\\n\\n    /// @notice used for weight scaling when unstaking with slashing.\\n    /// @return uint96 DEFAULT_WEIGHT_SCALING\\n    function weightScaling() external view returns (uint96);\\n\\n    /// @notice List of vesting contracts, tokens for these contracts won't be slashed if unstaked by governance.\\n    /// @dev vestingWhitelist[contract] is true/false.\\n    function vestingWhitelist(address isWhitelisted) external view returns (bool);\\n\\n    /// @dev user => flag whether user has admin role.\\n    /// @dev multisig should be an admin, admin can invoke only governanceWithdrawVesting function,\\n    /// \\tthis function works only with Team Vesting contracts\\n    function admins(address isAdmin) external view returns (bool);\\n\\n    /// @dev vesting contract code hash => flag whether it's registered code hash\\n    function vestingCodeHashes(bytes32 vestingLogicCodeHash) external view returns (bool);\\n\\n    /// @notice A record of tokens to be unstaked from vesting contract at a given time (lockDate -> vest checkpoint)\\n    /// @dev vestingCheckpoints[date][index] is a checkpoint.\\n    function vestingCheckpoints(\\n        uint256 date,\\n        uint32 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @notice The number of total vesting checkpoints for each date.\\n    /// @dev numVestingCheckpoints[date] is a number.\\n    function numVestingCheckpoints(uint256 date) external view returns (uint32 checkpointsQty);\\n\\n    ///@notice vesting registry contract PROXY address\\n    function vestingRegistryLogic() external view returns (address);\\n\\n    /// @dev user => flag whether user has pauser role.\\n    function pausers(address isPauser) external view returns (bool);\\n\\n    /// @dev Staking contract is paused\\n    function paused() external view returns (bool);\\n\\n    /// @dev Staking contract is frozen\\n    function frozen() external view returns (bool);\\n\\n    /*************************** StakingVestingModule ***************************/\\n\\n    event VestingStakeSet(uint256 lockedTS, uint96 value);\\n\\n    /**\\n     * @notice Return flag whether the given address is a registered vesting contract.\\n     * @param stakerAddress the address to check\\n     */\\n    function isVestingContract(address stakerAddress) external view returns (bool);\\n\\n    /**\\n     * @notice Remove vesting contract's code hash to a map of code hashes.\\n     * @param vesting The address of Vesting contract.\\n     * @dev We need it to use isVestingContract() function instead of isContract()\\n     */\\n    function removeContractCodeHash(address vesting) external;\\n\\n    /**\\n     * @notice Add vesting contract's code hash to a map of code hashes.\\n     * @param vesting The address of Vesting contract.\\n     * @dev We need it to use isVestingContract() function instead of isContract()\\n     */\\n    function addContractCodeHash(address vesting) external;\\n\\n    /**\\n     * @notice Determine the prior number of vested stake for an account until a\\n     * certain lock date as of a block number.\\n     * @dev Block number must be a finalized block or else this function\\n     * will revert to prevent misinformation.\\n     * @param date The lock date.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @return The number of votes the account had as of the given block.\\n     * */\\n    function getPriorVestingStakeByDate(\\n        uint256 date,\\n        uint256 blockNumber\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Compute the voting power for a specific date.\\n     * Power = stake * weight\\n     * @param date The staking date to compute the power for. Adjusted to the next valid lock date, if necessary.\\n     * @param startDate The date for which we need to know the power of the stake.\\n     * @param blockNumber The block number, needed for checkpointing.\\n     * @return The stacking power.\\n     * */\\n    function weightedVestingStakeByDate(\\n        uint256 date,\\n        uint256 startDate,\\n        uint256 blockNumber\\n    ) external view returns (uint96 power);\\n\\n    /**\\n     * @notice Determine the prior weighted vested amount for an account as of a block number.\\n     * Iterate through checkpoints adding up voting power.\\n     * @dev Block number must be a finalized block or else this function will\\n     * revert to prevent misinformation.\\n     *      Used for fee sharing, not voting.\\n     * TODO: WeightedStaking::getPriorVestingWeightedStake is using the variable name \\\"votes\\\"\\n     * to add up token stake, and that could be misleading.\\n     *\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @param date The staking date to compute the power for.\\n     * @return The weighted stake the account had as of the given block.\\n     * */\\n    function getPriorVestingWeightedStake(\\n        uint256 blockNumber,\\n        uint256 date\\n    ) external view returns (uint96 votes);\\n\\n    /**\\n     * @notice Determine the prior number of stake for an account until a\\n     * certain lock date as of a block number.\\n     * @dev Block number must be a finalized block or else this function\\n     * will revert to prevent misinformation.\\n     * @param account The address of the account to check.\\n     * @param date The lock date.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @return The number of votes the account had as of the given block.\\n     * */\\n    function getPriorUserStakeByDate(\\n        address account,\\n        uint256 date,\\n        uint256 blockNumber\\n    ) external view returns (uint96);\\n\\n    /**\\n     * @notice Sets the users' vesting stakes for a giving lock dates and writes checkpoints.\\n     * @param lockedDates The arrays of lock dates.\\n     * @param values The array of values to add to the staked balance.\\n     */\\n    function setVestingStakes(uint256[] calldata lockedDates, uint96[] calldata values) external;\\n\\n    /**\\n     * @notice sets vesting registry\\n     * @param _vestingRegistryProxy the address of vesting registry proxy contract\\n     * @dev _vestingRegistryProxy can be set to 0 as this function can be reused by\\n     * various other functionalities without the necessity of linking it with Vesting Registry\\n     */\\n    function setVestingRegistry(address _vestingRegistryProxy) external;\\n\\n    /*************************** StakingWithdrawModule ***************************/\\n\\n    /**\\n     * @notice Withdraw the given amount of tokens if they are unlocked.\\n     * @param amount The number of tokens to withdraw.\\n     * @param until The date until which the tokens were staked.\\n     * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\\n     * */\\n    function withdraw(uint96 amount, uint256 until, address receiver) external;\\n\\n    /**\\n     * @notice Withdraw the given amount of tokens.\\n     * @param amount The number of tokens to withdraw.\\n     * @param until The date until which the tokens were staked.\\n     * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\\n     * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting\\n     * @dev **WARNING** This function should not be no longer used by Sovryn Protocol.\\n     * Sovryn protocol will use the cancelTeamVesting function for the withdrawal moving forward.\\n     * */\\n    function governanceWithdraw(uint96 amount, uint256 until, address receiver) external;\\n\\n    /**\\n     * @notice Withdraw tokens for vesting contract.\\n     * @param vesting The address of Vesting contract.\\n     * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\\n     * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting.\\n     * */\\n    function governanceWithdrawVesting(address vesting, address receiver) external;\\n\\n    /**\\n     * @notice Get available and punished amount for withdrawing.\\n     * @param amount The number of tokens to withdraw.\\n     * @param until The date until which the tokens were staked.\\n     * */\\n    function getWithdrawAmounts(\\n        uint96 amount,\\n        uint256 until\\n    ) external view returns (uint96, uint96);\\n\\n    /**\\n     * @notice Allow the owner to unlock all tokens in case the staking contract\\n     * is going to be replaced\\n     * Note: Not reversible on purpose. once unlocked, everything is unlocked.\\n     * The owner should not be able to just quickly unlock to withdraw his own\\n     * tokens and lock again.\\n     * @dev Last resort.\\n     * */\\n    function unlockAllTokens() external;\\n\\n    /*************************** WeightedStakingModule ***************************/\\n\\n    /**\\n     * @notice Determine the prior weighted stake for an account as of a block number.\\n     * Iterate through checkpoints adding up voting power.\\n     * @dev Block number must be a finalized block or else this function will\\n     * revert to prevent misinformation.\\n     *      Used for fee sharing, not voting.\\n     *\\n     * @param account The address of the account to check.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @param date The date/timestamp of the unstaking time.\\n     * @return The weighted stake the account had as of the given block.\\n     * */\\n    function getPriorWeightedStake(\\n        address account,\\n        uint256 blockNumber,\\n        uint256 date\\n    ) external view returns (uint96 priorWeightedStake);\\n\\n    /**\\n     * @notice Compute the voting power for a specific date.\\n     * Power = stake * weight\\n     * TODO: WeightedStaking::weightedStakeByDate should probably better\\n     * be internal instead of a public function.\\n     * @param account The user address.\\n     * @param date The staking date to compute the power for.\\n     * @param startDate The date for which we need to know the power of the stake.\\n     * @param blockNumber The block number, needed for checkpointing.\\n     * @return The stacking power.\\n     * */\\n    function weightedStakeByDate(\\n        address account,\\n        uint256 date,\\n        uint256 startDate,\\n        uint256 blockNumber\\n    ) external view returns (uint96 power);\\n\\n    /**\\n     * @notice Compute the weight for a specific date.\\n     * @param date The unlocking date.\\n     * @param startDate We compute the weight for the tokens staked until 'date' on 'startDate'.\\n     * @return The weighted stake the account had as of the given block.\\n     * */\\n    function computeWeightByDate(\\n        uint256 date,\\n        uint256 startDate\\n    ) external pure returns (uint96 weight);\\n\\n    /**\\n     * @notice Returns public constant MAX_DURATION\\n     * preserved for backwards compatibility\\n     * Use getStorageMaxDurationToStakeTokens()\\n     * @return uint96 MAX_DURATION for staking\\n     **/\\n    function MAX_DURATION() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() external view returns (bool);\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Governance withdraw vesting directly through staking contract.\\n     * This direct withdraw vesting solves the out of gas issue when there are too many iterations when withdrawing.\\n     * This function only allows cancelling vesting contract of the TeamVesting type.\\n     *\\n     * @param vesting The vesting address.\\n     * @param receiver The receiving address.\\n     * @param startFrom The start value for the iterations.\\n     */\\n    function cancelTeamVesting(address vesting, address receiver, uint256 startFrom) external;\\n\\n    /**\\n     * @notice Max iteration for direct withdrawal from staking to prevent out of gas issue.\\n     *\\n     * @return max iteration value.\\n     */\\n    function getMaxVestingWithdrawIterations() external view returns (uint256);\\n\\n    /**\\n     * @dev set max withdraw iterations.\\n     *\\n     * @param maxIterations new max iterations value.\\n     */\\n    function setMaxVestingWithdrawIterations(uint256 maxIterations) external;\\n}\\n\",\"keccak256\":\"0xf9d0f9e354e4af13f94c27881b564e1c7c8a4117ab2e36ca6264b9d413fa7e8f\"},\"contracts/governance/StakingRewards/StakingRewardsOs.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport { StakingRewardsOsStorage, IStaking, IERC20Mintable } from \\\"./StakingRewardsOsStorage.sol\\\";\\nimport { SafeMath } from \\\"../../openzeppelin/SafeMath.sol\\\";\\nimport { Address } from \\\"../../openzeppelin/Address.sol\\\";\\nimport { Initializable } from \\\"../../openzeppelin/Initializable.sol\\\";\\n\\n/**\\n * @title Staking Rewards Contract.\\n * @notice This is a trial incentive program.\\n * In this, the osSOV minted to voluntary stakers and is locked until transferred to BitcoinOS\\n * */\\ncontract StakingRewardsOs is StakingRewardsOsStorage, Initializable {\\n    using SafeMath for uint256;\\n\\n    /// @notice Emitted when osSOV is withdrawn\\n    /// @param receiver The address which recieves the osSOV\\n    /// @param amount The amount withdrawn from the Smart Contract\\n    event RewardWithdrawn(address indexed receiver, uint256 amount);\\n\\n    /**\\n     * @notice Replacement of constructor by initialize function for Upgradable Contracts\\n     * This function will be called only once by the owner.\\n     * @param _osSOV osSOV token address\\n     * @param _staking StakingProxy address should be passed\\n     * @param _averageBlockTime average block time used for calculating rewards\\n     * */\\n    function initialize(\\n        address _osSOV,\\n        IStaking _staking,\\n        uint256 _averageBlockTime\\n    ) external onlyOwner initializer {\\n        require(_osSOV != address(0), \\\"Invalid OsSOV Address\\\");\\n        require(Address.isContract(_osSOV), \\\"OsSOV is not a contract\\\");\\n        osSOV = IERC20Mintable(_osSOV);\\n        staking = _staking;\\n        rewardsProgramStartTime = staking.timestampToLockDate(block.timestamp);\\n        maxDuration = 15 * TWO_WEEKS;\\n        deploymentBlock = _getCurrentBlockNumber();\\n        averageBlockTime = _averageBlockTime;\\n    }\\n\\n    /**\\n     * @notice Stops the current rewards program.\\n     * @dev Users will only get rewards up to the stop block\\n     * */\\n    function stop() external onlyOwner {\\n        require(stopBlock == 0, \\\"Already stopped\\\");\\n        stopBlock = _getCurrentBlockNumber();\\n        stopRewardsTimestamp = staking.timestampToLockDate(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Collect rewards\\n     * @dev User calls this function to collect osSOV staking rewards accrued by this contract\\n     * The weighted stake is calculated using getPriorWeightedStake. Block number sent to the functon\\n     * must be a finalised block, hence we deduct 1 from the current block. User is only allowed to withdraw\\n     * after intervals of 14 days.\\n     * @param _startTime The time from which to start the staking rewards calculation\\n     * The issue is that we can only run for a max duration and if someone stakes for the\\n     * first time after the max duration is over, the reward will always return 0. Thus, we need to restart\\n     * from the duration that elapsed without generating rewards.\\n     * */\\n    function collectReward(uint256 _startTime) external {\\n        require(\\n            stopBlock == 0 || stakerNextWithdrawTimestamp[msg.sender] < stopRewardsTimestamp,\\n            \\\"Entire reward already paid\\\"\\n        );\\n        (uint256 withdrawTimestamp, uint256 amount) = _getStakerCurrentReward(\\n            msg.sender,\\n            true,\\n            _startTime\\n        );\\n        require(withdrawTimestamp > 0 && amount > 0, \\\"No valid reward\\\");\\n        stakerNextWithdrawTimestamp[msg.sender] = withdrawTimestamp;\\n        _payReward(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Changes average block time - based on blockchain\\n     * @dev If average block time significantly changes, we can update it here and use for block number calculation\\n     * @param _averageBlockTime - average block time used for calculating checkpoint blocks\\n     */\\n    function setAverageBlockTime(uint256 _averageBlockTime) external onlyOwner {\\n        averageBlockTime = _averageBlockTime;\\n    }\\n\\n    /**\\n     * @notice This function computes the last staking checkpoint and calculates the corresponding\\n     * block number using the average block time which is then added to the mapping `checkpointBlockNumber`.\\n     */\\n    function setBlock() external {\\n        uint256 lastCheckpointTime = staking.timestampToLockDate(block.timestamp);\\n        _setBlock(lastCheckpointTime);\\n    }\\n\\n    /**\\n     * @notice This function computes the block number using the average block time for a given historical\\n     * checkpoint which is added to the mapping `checkpointBlockNumber`.\\n     * @param _time Exact staking checkpoint time\\n     */\\n    function setHistoricalBlock(uint256 _time) external {\\n        _setBlock(_time);\\n    }\\n\\n    /**\\n     * @notice Sets the max duration\\n     * @dev Rewards can be collected for a maximum duration at a time. This\\n     * is to avoid Block Gas Limit failures. Setting it zero would mean that it will loop\\n     * through the entire duration since the start of rewards program.\\n     * It should ideally be set to a value, for which the rewards can be easily processed.\\n     * @param _duration Max duration for which rewards can be collected at a go (in seconds)\\n     * */\\n    function setMaxDuration(uint256 _duration) public onlyOwner {\\n        maxDuration = _duration;\\n    }\\n\\n    /**\\n     * @notice Internal function to calculate weighted stake\\n     * @dev Users will receive rewards uo till the stop block\\n     * @param _staker Staker address\\n     * @param _block Last finalised block\\n     * @param _date The date to compute prior weighted stakes\\n     * @return The weighted stake\\n     * */\\n    function _computeWeightedStakeForDate(\\n        address _staker,\\n        uint256 _block,\\n        uint256 _date\\n    ) internal view returns (uint256 weightedStake) {\\n        return staking.getPriorWeightedStake(_staker, _block, _date);\\n    }\\n\\n    /**\\n     * @notice Internal function to pay rewards\\n     * @dev Base rate is annual, but we pay interest for 14 days,\\n     * which is 1/26 of one staking year (1092 days)\\n     * @param _staker Staker address\\n     * @param _amount the reward amount\\n     * */\\n    function _payReward(address _staker, uint256 _amount) internal {\\n        require(_amount != 0, \\\"amount invalid\\\");\\n        claimedBalances[_staker] = claimedBalances[_staker].add(_amount);\\n        osSOV.mint(_staker, _amount);\\n        emit RewardWithdrawn(_staker, _amount);\\n    }\\n\\n    /**\\n     * @notice Determine the current Block Number\\n     * @dev This is segregated from the _getPriorUserStakeByDate function to better test\\n     * advancing blocks functionality using Mock Contracts\\n     * */\\n    function _getCurrentBlockNumber() internal view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Internal function to calculate and set block\\n     * */\\n    function _setBlock(uint256 _checkpointTime) internal {\\n        uint256 lastFinalisedBlock = _getCurrentBlockNumber() - 1;\\n        require(checkpointBlockNumber[_checkpointTime] == 0, \\\"block number already set\\\");\\n        uint256 checkpointBlock = lastFinalisedBlock.sub(\\n            ((block.timestamp.sub(_checkpointTime)).div(averageBlockTime))\\n        );\\n        checkpointBlockNumber[_checkpointTime] = checkpointBlock;\\n    }\\n\\n    /**\\n     * @notice Get staker's current accumulated reward\\n     * @dev getStakerCurrentReward function internally calls this function to calculate reward amount of msg.sender\\n     * @param _considerMaxDuration True: Runs for the maximum duration - used in tx not to run out of gas\\n     * False - to query total rewards\\n     * @param _startTime The time from which the staking rewards calculation shall restart.\\n     * @return The timestamp of last withdrawal\\n     * @return The accumulated reward\\n     */\\n    function getStakerCurrentReward(\\n        bool _considerMaxDuration,\\n        uint256 _startTime\\n    ) external view returns (uint256 nextWithdrawTimestamp, uint256 amount) {\\n        return _getStakerCurrentReward(msg.sender, _considerMaxDuration, _startTime);\\n    }\\n\\n    /**\\n     * @notice Get any staker's current accumulated reward\\n     * @dev getArbitraryStakerCurrentReward function internally calls this function to calculate reward amount\\n     * @param _considerMaxDuration True: Runs for the maximum duration - used in tx not to run out of gas\\n     * False - to query total rewards\\n     * @param _startTime The time from which the staking rewards calculation shall restart.\\n     * @param _staker The staker address to calculate rewards for\\n     * @return The timestamp of last withdrawal\\n     * @return The accumulated reward\\n     */\\n    function getArbitraryStakerCurrentReward(\\n        bool _considerMaxDuration,\\n        uint256 _startTime,\\n        address _staker\\n    ) external view returns (uint256 nextWithdrawTimestamp, uint256 amount) {\\n        return _getStakerCurrentReward(_staker, _considerMaxDuration, _startTime);\\n    }\\n\\n    struct RewardsInterval {\\n        uint256 fromTimestamp;\\n        uint256 toTimestamp;\\n    }\\n\\n    /**\\n     * @notice Internal function to calculate staker's current reward\\n     * @dev Normally the start time is 0. If this function returns a valid withdraw timestamp\\n     * and zero amount - that means there were no valid rewards for that period. So the new period must start\\n     * from the end of the last interval or till the time no rewards are accumulated i.e. _startTime\\n     */\\n    function _getStakerCurrentReward(\\n        address _staker,\\n        bool _considerMaxDuration,\\n        uint256 _startTime\\n    ) internal view returns (uint256 nextWithdrawTimestamp, uint256 amount) {\\n        uint256 weightedStake;\\n        uint256 lastFinalisedBlock;\\n        RewardsInterval memory rewardsInterval;\\n        uint256 currentBlockTsToLockDate;\\n        uint256 startWithdrawTimestamp = stakerNextWithdrawTimestamp[_staker];\\n\\n        if (stopBlock != 0 && startWithdrawTimestamp > stopRewardsTimestamp) {\\n            return (startWithdrawTimestamp, 0);\\n        }\\n\\n        // interval left boundary\\n        if (_startTime < rewardsProgramStartTime) {\\n            rewardsInterval.fromTimestamp = startWithdrawTimestamp > 0\\n                ? startWithdrawTimestamp\\n                : rewardsProgramStartTime;\\n        } else if (_startTime > startWithdrawTimestamp) {\\n            rewardsInterval.fromTimestamp = staking.timestampToLockDate(_startTime);\\n        } else {\\n            rewardsInterval.fromTimestamp = startWithdrawTimestamp;\\n        }\\n\\n        // interval right boundary\\n        currentBlockTsToLockDate = staking.timestampToLockDate(block.timestamp);\\n        if (_considerMaxDuration) {\\n            uint256 endWithdrawTimestamp = staking.timestampToLockDate(\\n                rewardsInterval.fromTimestamp.add(maxDuration)\\n            );\\n            rewardsInterval.toTimestamp = endWithdrawTimestamp > currentBlockTsToLockDate\\n                ? currentBlockTsToLockDate\\n                : endWithdrawTimestamp;\\n        } else {\\n            rewardsInterval.toTimestamp = currentBlockTsToLockDate;\\n        }\\n\\n        if (stopRewardsTimestamp > 0 && rewardsInterval.toTimestamp >= stopRewardsTimestamp) {\\n            rewardsInterval.toTimestamp = stopRewardsTimestamp.add(TWO_WEEKS);\\n        }\\n\\n        if (rewardsInterval.fromTimestamp > rewardsInterval.toTimestamp) {\\n            return (rewardsInterval.fromTimestamp, 0);\\n        }\\n\\n        lastFinalisedBlock = _getCurrentBlockNumber() - 1;\\n\\n        for (\\n            uint256 i = rewardsInterval.fromTimestamp;\\n            i < rewardsInterval.toTimestamp;\\n            i += TWO_WEEKS\\n        ) {\\n            uint256 referenceBlock = checkpointBlockNumber[i];\\n            if (referenceBlock == 0) {\\n                referenceBlock = lastFinalisedBlock.sub(\\n                    ((block.timestamp.sub(i)).div(averageBlockTime))\\n                );\\n            }\\n            if (referenceBlock < deploymentBlock) {\\n                referenceBlock = deploymentBlock;\\n            }\\n            weightedStake = weightedStake.add(\\n                _computeWeightedStakeForDate(_staker, referenceBlock, i)\\n            );\\n        }\\n        nextWithdrawTimestamp = rewardsInterval.toTimestamp.add(TWO_WEEKS);\\n        amount = weightedStake.mul(BASE_RATE).div(DIVISOR);\\n    }\\n}\\n\",\"keccak256\":\"0xd7e63f6548ddc30416b7652099bdcd22bdd7443652367dd555dac9297348d654\"},\"contracts/governance/StakingRewards/StakingRewardsOsStorage.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport { IERC20Mintable } from \\\"../../interfaces/IERC20Mintable.sol\\\";\\nimport { IStaking } from \\\"../Staking/interfaces/IStaking.sol\\\";\\nimport { Ownable } from \\\"../../openzeppelin/Ownable.sol\\\";\\n\\n/**\\n * @title Staking Rewards Storage Contract.\\n * @notice Just the storage part of staking rewards contract, no functions,\\n * only constant, variables and required structures (mappings).\\n * Used by StackingRewardsProxy.\\n *\\n * What is SOV staking rewards ?\\n * The purpose of the SOV staking rewards program is to reward,\\n * \\\"marginal stakers\\\" (ie, stakers by choice, not currently vesting) with liquid SOV\\n * at the beginning of each new staking interval.\\n * */\\ncontract StakingRewardsOsStorage is Ownable {\\n    /// @notice 2 weeks in seconds.\\n    uint256 public constant TWO_WEEKS = 1209600;\\n\\n    /// @notice Annual Base Rate - it is the maximum interest rate(APY)\\n    uint256 public constant BASE_RATE = 900;\\n\\n    /// @notice DIVISOR is set as 2600000 = 26 (num periods per year) * 10 (max voting weight) * 10000 (900 -> 0.09)\\n    uint256 public constant DIVISOR = 2600000;\\n\\n    /// @notice The SOV token contract.\\n    // solhint-disable private-vars-leading-underscore\\n    IERC20Mintable internal osSOV;\\n\\n    /// @notice the staking proxy contract address\\n    IStaking internal staking;\\n\\n    /// @notice Maximum duration to collect rewards at one go\\n    uint256 internal maxDuration;\\n\\n    /// @notice Represents the time when the contract is deployed\\n    uint256 internal rewardsProgramStartTime;\\n\\n    /// @notice Represents the block when the Staking Rewards pogram is stopped\\n    uint256 internal stopBlock;\\n\\n    /// @notice Timestamp of the stopBlock adjusted to the staking lock timestamp\\n    uint256 internal stopRewardsTimestamp;\\n\\n    /// @notice User Address -> Next Withdrawn Timestamp\\n    mapping(address => uint256) internal stakerNextWithdrawTimestamp;\\n\\n    /// @notice User Address -> Claimed Balance\\n    mapping(address => uint256) internal claimedBalances;\\n\\n    /// @notice Represents the block when the StakingRwards Program is started\\n    uint256 internal deploymentBlock;\\n\\n    /// @notice BlockTime -> BlockNumber for a Staking Checkpoint\\n    mapping(uint256 => uint256) internal checkpointBlockNumber;\\n\\n    /// @notice Average Block Time - making it flexible\\n    uint256 internal averageBlockTime;\\n\\n    /// @param _checkpointTimestamp Checkpoint timestamp\\n    function getCheckpointBlockNumber(\\n        uint256 _checkpointTimestamp\\n    ) external view returns (uint256) {\\n        return checkpointBlockNumber[_checkpointTimestamp];\\n    }\\n\\n    function getOsSOV() external view returns (IERC20Mintable) {\\n        return osSOV;\\n    }\\n\\n    function getStaking() external view returns (IStaking) {\\n        return staking;\\n    }\\n\\n    function getMaxDuration() external view returns (uint256) {\\n        return maxDuration;\\n    }\\n\\n    function getRewardsProgramStartTime() external view returns (uint256) {\\n        return rewardsProgramStartTime;\\n    }\\n\\n    function getStopBlock() external view returns (uint256) {\\n        return stopBlock;\\n    }\\n\\n    function getStopRewardsTimestamp() external view returns (uint256) {\\n        return stopRewardsTimestamp;\\n    }\\n\\n    function getStakerNextWithdrawTimestamp(address _staker) external view returns (uint256) {\\n        return stakerNextWithdrawTimestamp[_staker];\\n    }\\n\\n    function getDeploymentBlock() external view returns (uint256) {\\n        return deploymentBlock;\\n    }\\n\\n    function getAverageBlockTime() external view returns (uint256) {\\n        return averageBlockTime;\\n    }\\n}\\n\",\"keccak256\":\"0xdc68e41c7a2c721d33eed6f4b83a87a54b7632cc37577b4dd4908f6fdd8bad06\"},\"contracts/interfaces/IERC20Mintable.sol\":{\"content\":\"/**\\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity >=0.5.0 <0.6.0;\\n\\ncontract IERC20Mintable {\\n    string public name;\\n    uint8 public decimals;\\n    string public symbol;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _who) external view returns (uint256);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    function mint(address _to, uint256 _value) external;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xeebb5e65f388bc65d22f16fd0ef21d96cb0dc890daaa3d13cd2c935f4c2e1c11\"},\"contracts/openzeppelin/Address.sol\":{\"content\":\"pragma solidity >=0.5.0 <0.6.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html\\n     *   #use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x23df48a01dbac9b25e86c9131174fb7752bbc7e741e63f1aa982de22e055ad54\"},\"contracts/openzeppelin/Context.sol\":{\"content\":\"pragma solidity >=0.5.0 <0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7860cb1591dbd66bb497c60c46866d9fcdb56c73306ed86b25801000af1c7b2b\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"pragma solidity >=0.5.0 <0.6.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa5064e2730ae1037f4efc83654676174484b827890d30ee618048004a04d6b51\"},\"contracts/openzeppelin/Ownable.sol\":{\"content\":\"pragma solidity >=0.5.0 <0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x94496c375b3e82d87d7f01ce1577f008fab374312cf93012a0eca716e6aadb3a\"},\"contracts/openzeppelin/SafeMath.sol\":{\"content\":\"pragma solidity >=0.5.0 <0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b != 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, rounding up and truncating the quotient\\n     */\\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return divCeil(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, rounding up and truncating the quotient\\n     */\\n    function divCeil(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b != 0, errorMessage);\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = ((a - 1) / b) + 1;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return _a < _b ? _a : _b;\\n    }\\n}\\n\",\"keccak256\":\"0xbff8d6273e1a6870d1a142c0c23acd63a4dd47760f250390f49ee56333bcb6e8\"}},\"version\":1}",
  "bytecode": "0x608060405260006100176001600160e01b0361006616565b600080546001600160a01b0319166001600160a01b0383169081178255604051929350917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a35061006a565b3390565b611436806100796000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063934d1fa4116100de578063dffd356211610097578063f92ac1f111610071578063f92ac1f11461037b578063f9e28d0d146103a1578063fe5afe51146103a9578063fed73f66146103b157610173565b8063dffd356214610330578063f2fde38b1461034d578063f5f52e2e1461037357610173565b8063934d1fa4146102b9578063b49a2db9146102c1578063bd3507da146102c9578063ce6da7f2146102e6578063ceee6855146102ee578063cf0f34c41461031357610173565b8063722a23db11610130578063722a23db146102445780637b1391a61461026157806380d1cb35146102855780638da5cb5b1461028d5780638f32d59b146102955780638fd35c65146102b157610173565b8063066b3c041461017857806307da68f5146101c55780631794bb3c146101cf5780633410fe6e146102055780633736d8531461021f57806341910f901461023c575b600080fd5b6101ac6004803603606081101561018e57600080fd5b508035151590602081013590604001356001600160a01b03166103b9565b6040805192835260208301919091528051918290030190f35b6101cd6103d4565b005b6101cd600480360360608110156101e557600080fd5b506001600160a01b038135811691602081013590911690604001356104ea565b61020d61072d565b60408051918252519081900360200190f35b6101cd6004803603602081101561023557600080fd5b5035610734565b61020d610781565b61020d6004803603602081101561025a57600080fd5b5035610787565b610269610799565b604080516001600160a01b039092168252519081900360200190f35b61020d6107a8565b6102696107ae565b61029d6107bd565b604080519115158252519081900360200190f35b6102696107e1565b61020d6107f0565b61020d6107f7565b6101cd600480360360208110156102df57600080fd5b50356107fd565b61020d6108f4565b6101ac6004803603604081101561030457600080fd5b508035151590602001356108fa565b6101cd6004803603602081101561032957600080fd5b5035610913565b6101cd6004803603602081101561034657600080fd5b5035610960565b6101cd6004803603602081101561036357600080fd5b50356001600160a01b031661096c565b61020d6109bd565b61020d6004803603602081101561039157600080fd5b50356001600160a01b03166109c3565b61020d6109de565b6101cd6109e4565b61020d610a66565b6000806103c7838686610a6c565b915091505b935093915050565b6103dc6107bd565b61041c576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b60055415610463576040805162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e481cdd1bdc1c1959608a1b604482015290519081900360640190fd5b61046b610dcf565b600555600254604080516372ec979560e01b815242600482015290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b1580156104b957600080fd5b505afa1580156104cd573d6000803e3d6000fd5b505050506040513d60208110156104e357600080fd5b5051600655565b6104f26107bd565b610532576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600c54610100900460ff168061054b5750600c5460ff16155b6105865760405162461bcd60e51b815260040180806020018281038252602e8152602001806113b3602e913960400191505060405180910390fd5b600c54610100900460ff161580156105b157600c805460ff1961ff0019909116610100171660011790555b6001600160a01b038416610604576040805162461bcd60e51b8152602060048201526015602482015274496e76616c6964204f73534f56204164647265737360581b604482015290519081900360640190fd5b61060d84610dd3565b61065e576040805162461bcd60e51b815260206004820152601760248201527f4f73534f56206973206e6f74206120636f6e7472616374000000000000000000604482015290519081900360640190fd5b600180546001600160a01b038087166001600160a01b0319928316179092556002805486841692169190911790819055604080516372ec979560e01b8152426004820152905191909216916372ec9795916024808301926020929190829003018186803b1580156106ce57600080fd5b505afa1580156106e2573d6000803e3d6000fd5b505050506040513d60208110156106f857600080fd5b5051600455630114db0060035561070d610dcf565b600955600b829055801561072757600c805461ff00191690555b50505050565b6227ac4081565b61073c6107bd565b61077c576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600b55565b61038481565b6000908152600a602052604090205490565b6002546001600160a01b031690565b60095490565b6000546001600160a01b031690565b600080546001600160a01b03166107d2610e0f565b6001600160a01b031614905090565b6001546001600160a01b031690565b6212750081565b60035490565b600554158061081c575060065433600090815260076020526040902054105b61086d576040805162461bcd60e51b815260206004820152601a60248201527f456e746972652072657761726420616c72656164792070616964000000000000604482015290519081900360640190fd5b60008061087c33600185610a6c565b915091506000821180156108905750600081115b6108d3576040805162461bcd60e51b815260206004820152600f60248201526e139bc81d985b1a59081c995dd85c99608a1b604482015290519081900360640190fd5b3360008181526007602052604090208390556108ef9082610e13565b505050565b60065490565b600080610908338585610a6c565b915091509250929050565b61091b6107bd565b61095b576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600355565b61096981610f41565b50565b6109746107bd565b6109b4576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b61096981610ff5565b60055490565b6001600160a01b031660009081526007602052604090205490565b600b5490565b600254604080516372ec979560e01b815242600482015290516000926001600160a01b0316916372ec9795916024808301926020929190829003018186803b158015610a2f57600080fd5b505afa158015610a43573d6000803e3d6000fd5b505050506040513d6020811015610a5957600080fd5b5051905061096981610f41565b60045490565b600080600080610a7a611372565b6001600160a01b03881660009081526007602052604081205460055415801590610aa5575060065481115b15610aba579550600094506103cc9350505050565b600454881015610add5760008111610ad457600454610ad6565b805b8352610b68565b80881115610b6457600254604080516372ec979560e01b8152600481018b905290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b158015610b3157600080fd5b505afa158015610b45573d6000803e3d6000fd5b505050506040513d6020811015610b5b57600080fd5b50518352610b68565b8083525b600254604080516372ec979560e01b815242600482015290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b158015610bb357600080fd5b505afa158015610bc7573d6000803e3d6000fd5b505050506040513d6020811015610bdd57600080fd5b505191508815610c8d5760025460035484516000926001600160a01b0316916372ec979591610c119163ffffffff61109516565b6040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b158015610c4557600080fd5b505afa158015610c59573d6000803e3d6000fd5b505050506040513d6020811015610c6f57600080fd5b50519050828111610c805780610c82565b825b602085015250610c95565b602083018290525b6000600654118015610cad5750600654836020015110155b15610cce57600654610cc8906212750063ffffffff61109516565b60208401525b602083015183511115610cec575050519350600092506103cc915050565b6001610cf6610dcf565b845191900394505b8360200151811015610d8c576000818152600a602052604090205480610d5557600b54610d5290610d4590610d39428663ffffffff6110f816565b9063ffffffff61113a16565b879063ffffffff6110f816565b90505b600954811015610d6457506009545b610d7f610d728d838561117c565b889063ffffffff61109516565b9650506212750001610cfe565b506020830151610da5906212750063ffffffff61109516565b9650610dc06227ac40610d398761038463ffffffff61121d16565b95505050505050935093915050565b4390565b6000813f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470818114801590610e0757508115155b949350505050565b3390565b80610e56576040805162461bcd60e51b815260206004820152600e60248201526d185b5bdd5b9d081a5b9d985b1a5960921b604482015290519081900360640190fd5b6001600160a01b038216600090815260086020526040902054610e7f908263ffffffff61109516565b6001600160a01b038084166000818152600860205260408082209490945560015484516340c10f1960e01b8152600481019390935260248301869052935193909216926340c10f199260448084019391929182900301818387803b158015610ee657600080fd5b505af1158015610efa573d6000803e3d6000fd5b50506040805184815290516001600160a01b03861693507f1d3eee4ca001cff39eec6ec7615aacf2f2bd61791273830728ba00ccbd6e133792509081900360200190a25050565b60006001610f4d610dcf565b6000848152600a6020526040902054919003915015610fb3576040805162461bcd60e51b815260206004820152601860248201527f626c6f636b206e756d62657220616c7265616479207365740000000000000000604482015290519081900360640190fd5b6000610fde610fd1600b54610d3986426110f890919063ffffffff16565b839063ffffffff6110f816565b6000938452600a6020526040909320929092555050565b6001600160a01b03811661103a5760405162461bcd60e51b815260040180806020018281038252602681526020018061138d6026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000828201838110156110ef576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b90505b92915050565b60006110ef83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250611276565b60006110ef83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f00000000000081525061130d565b600254604080516337e6b1c160e01b81526001600160a01b0386811660048301526024820186905260448201859052915160009392909216916337e6b1c191606480820192602092909190829003018186803b1580156111db57600080fd5b505afa1580156111ef573d6000803e3d6000fd5b505050506040513d602081101561120557600080fd5b50516bffffffffffffffffffffffff16949350505050565b60008261122c575060006110f2565b8282028284828161123957fe5b04146110ef5760405162461bcd60e51b81526004018080602001828103825260218152602001806113e16021913960400191505060405180910390fd5b600081848411156113055760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156112ca5781810151838201526020016112b2565b50505050905090810190601f1680156112f75780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b6000818361135c5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156112ca5781810151838201526020016112b2565b50600083858161136857fe5b0495945050505050565b60405180604001604052806000815260200160008152509056fe4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061646472657373496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a72315820a968aa1d1c21f9ba9e804fef932b96a73550d9f45df4cbf05f1c854e9ef705d364736f6c63430005110032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101735760003560e01c8063934d1fa4116100de578063dffd356211610097578063f92ac1f111610071578063f92ac1f11461037b578063f9e28d0d146103a1578063fe5afe51146103a9578063fed73f66146103b157610173565b8063dffd356214610330578063f2fde38b1461034d578063f5f52e2e1461037357610173565b8063934d1fa4146102b9578063b49a2db9146102c1578063bd3507da146102c9578063ce6da7f2146102e6578063ceee6855146102ee578063cf0f34c41461031357610173565b8063722a23db11610130578063722a23db146102445780637b1391a61461026157806380d1cb35146102855780638da5cb5b1461028d5780638f32d59b146102955780638fd35c65146102b157610173565b8063066b3c041461017857806307da68f5146101c55780631794bb3c146101cf5780633410fe6e146102055780633736d8531461021f57806341910f901461023c575b600080fd5b6101ac6004803603606081101561018e57600080fd5b508035151590602081013590604001356001600160a01b03166103b9565b6040805192835260208301919091528051918290030190f35b6101cd6103d4565b005b6101cd600480360360608110156101e557600080fd5b506001600160a01b038135811691602081013590911690604001356104ea565b61020d61072d565b60408051918252519081900360200190f35b6101cd6004803603602081101561023557600080fd5b5035610734565b61020d610781565b61020d6004803603602081101561025a57600080fd5b5035610787565b610269610799565b604080516001600160a01b039092168252519081900360200190f35b61020d6107a8565b6102696107ae565b61029d6107bd565b604080519115158252519081900360200190f35b6102696107e1565b61020d6107f0565b61020d6107f7565b6101cd600480360360208110156102df57600080fd5b50356107fd565b61020d6108f4565b6101ac6004803603604081101561030457600080fd5b508035151590602001356108fa565b6101cd6004803603602081101561032957600080fd5b5035610913565b6101cd6004803603602081101561034657600080fd5b5035610960565b6101cd6004803603602081101561036357600080fd5b50356001600160a01b031661096c565b61020d6109bd565b61020d6004803603602081101561039157600080fd5b50356001600160a01b03166109c3565b61020d6109de565b6101cd6109e4565b61020d610a66565b6000806103c7838686610a6c565b915091505b935093915050565b6103dc6107bd565b61041c576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b60055415610463576040805162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e481cdd1bdc1c1959608a1b604482015290519081900360640190fd5b61046b610dcf565b600555600254604080516372ec979560e01b815242600482015290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b1580156104b957600080fd5b505afa1580156104cd573d6000803e3d6000fd5b505050506040513d60208110156104e357600080fd5b5051600655565b6104f26107bd565b610532576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600c54610100900460ff168061054b5750600c5460ff16155b6105865760405162461bcd60e51b815260040180806020018281038252602e8152602001806113b3602e913960400191505060405180910390fd5b600c54610100900460ff161580156105b157600c805460ff1961ff0019909116610100171660011790555b6001600160a01b038416610604576040805162461bcd60e51b8152602060048201526015602482015274496e76616c6964204f73534f56204164647265737360581b604482015290519081900360640190fd5b61060d84610dd3565b61065e576040805162461bcd60e51b815260206004820152601760248201527f4f73534f56206973206e6f74206120636f6e7472616374000000000000000000604482015290519081900360640190fd5b600180546001600160a01b038087166001600160a01b0319928316179092556002805486841692169190911790819055604080516372ec979560e01b8152426004820152905191909216916372ec9795916024808301926020929190829003018186803b1580156106ce57600080fd5b505afa1580156106e2573d6000803e3d6000fd5b505050506040513d60208110156106f857600080fd5b5051600455630114db0060035561070d610dcf565b600955600b829055801561072757600c805461ff00191690555b50505050565b6227ac4081565b61073c6107bd565b61077c576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600b55565b61038481565b6000908152600a602052604090205490565b6002546001600160a01b031690565b60095490565b6000546001600160a01b031690565b600080546001600160a01b03166107d2610e0f565b6001600160a01b031614905090565b6001546001600160a01b031690565b6212750081565b60035490565b600554158061081c575060065433600090815260076020526040902054105b61086d576040805162461bcd60e51b815260206004820152601a60248201527f456e746972652072657761726420616c72656164792070616964000000000000604482015290519081900360640190fd5b60008061087c33600185610a6c565b915091506000821180156108905750600081115b6108d3576040805162461bcd60e51b815260206004820152600f60248201526e139bc81d985b1a59081c995dd85c99608a1b604482015290519081900360640190fd5b3360008181526007602052604090208390556108ef9082610e13565b505050565b60065490565b600080610908338585610a6c565b915091509250929050565b61091b6107bd565b61095b576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b600355565b61096981610f41565b50565b6109746107bd565b6109b4576040805162461bcd60e51b815260206004820152600c60248201526b1d5b985d5d1a1bdc9a5e995960a21b604482015290519081900360640190fd5b61096981610ff5565b60055490565b6001600160a01b031660009081526007602052604090205490565b600b5490565b600254604080516372ec979560e01b815242600482015290516000926001600160a01b0316916372ec9795916024808301926020929190829003018186803b158015610a2f57600080fd5b505afa158015610a43573d6000803e3d6000fd5b505050506040513d6020811015610a5957600080fd5b5051905061096981610f41565b60045490565b600080600080610a7a611372565b6001600160a01b03881660009081526007602052604081205460055415801590610aa5575060065481115b15610aba579550600094506103cc9350505050565b600454881015610add5760008111610ad457600454610ad6565b805b8352610b68565b80881115610b6457600254604080516372ec979560e01b8152600481018b905290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b158015610b3157600080fd5b505afa158015610b45573d6000803e3d6000fd5b505050506040513d6020811015610b5b57600080fd5b50518352610b68565b8083525b600254604080516372ec979560e01b815242600482015290516001600160a01b03909216916372ec979591602480820192602092909190829003018186803b158015610bb357600080fd5b505afa158015610bc7573d6000803e3d6000fd5b505050506040513d6020811015610bdd57600080fd5b505191508815610c8d5760025460035484516000926001600160a01b0316916372ec979591610c119163ffffffff61109516565b6040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b158015610c4557600080fd5b505afa158015610c59573d6000803e3d6000fd5b505050506040513d6020811015610c6f57600080fd5b50519050828111610c805780610c82565b825b602085015250610c95565b602083018290525b6000600654118015610cad5750600654836020015110155b15610cce57600654610cc8906212750063ffffffff61109516565b60208401525b602083015183511115610cec575050519350600092506103cc915050565b6001610cf6610dcf565b845191900394505b8360200151811015610d8c576000818152600a602052604090205480610d5557600b54610d5290610d4590610d39428663ffffffff6110f816565b9063ffffffff61113a16565b879063ffffffff6110f816565b90505b600954811015610d6457506009545b610d7f610d728d838561117c565b889063ffffffff61109516565b9650506212750001610cfe565b506020830151610da5906212750063ffffffff61109516565b9650610dc06227ac40610d398761038463ffffffff61121d16565b95505050505050935093915050565b4390565b6000813f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470818114801590610e0757508115155b949350505050565b3390565b80610e56576040805162461bcd60e51b815260206004820152600e60248201526d185b5bdd5b9d081a5b9d985b1a5960921b604482015290519081900360640190fd5b6001600160a01b038216600090815260086020526040902054610e7f908263ffffffff61109516565b6001600160a01b038084166000818152600860205260408082209490945560015484516340c10f1960e01b8152600481019390935260248301869052935193909216926340c10f199260448084019391929182900301818387803b158015610ee657600080fd5b505af1158015610efa573d6000803e3d6000fd5b50506040805184815290516001600160a01b03861693507f1d3eee4ca001cff39eec6ec7615aacf2f2bd61791273830728ba00ccbd6e133792509081900360200190a25050565b60006001610f4d610dcf565b6000848152600a6020526040902054919003915015610fb3576040805162461bcd60e51b815260206004820152601860248201527f626c6f636b206e756d62657220616c7265616479207365740000000000000000604482015290519081900360640190fd5b6000610fde610fd1600b54610d3986426110f890919063ffffffff16565b839063ffffffff6110f816565b6000938452600a6020526040909320929092555050565b6001600160a01b03811661103a5760405162461bcd60e51b815260040180806020018281038252602681526020018061138d6026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000828201838110156110ef576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b90505b92915050565b60006110ef83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250611276565b60006110ef83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f00000000000081525061130d565b600254604080516337e6b1c160e01b81526001600160a01b0386811660048301526024820186905260448201859052915160009392909216916337e6b1c191606480820192602092909190829003018186803b1580156111db57600080fd5b505afa1580156111ef573d6000803e3d6000fd5b505050506040513d602081101561120557600080fd5b50516bffffffffffffffffffffffff16949350505050565b60008261122c575060006110f2565b8282028284828161123957fe5b04146110ef5760405162461bcd60e51b81526004018080602001828103825260218152602001806113e16021913960400191505060405180910390fd5b600081848411156113055760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156112ca5781810151838201526020016112b2565b50505050905090810190601f1680156112f75780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b6000818361135c5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156112ca5781810151838201526020016112b2565b50600083858161136857fe5b0495945050505050565b60405180604001604052806000815260200160008152509056fe4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061646472657373496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a72315820a968aa1d1c21f9ba9e804fef932b96a73550d9f45df4cbf05f1c854e9ef705d364736f6c63430005110032",
  "devdoc": {
    "methods": {
      "collectReward(uint256)": {
        "details": "User calls this function to collect osSOV staking rewards accrued by this contract The weighted stake is calculated using getPriorWeightedStake. Block number sent to the functon must be a finalised block, hence we deduct 1 from the current block. User is only allowed to withdraw after intervals of 14 days.",
        "params": {
          "_startTime": "The time from which to start the staking rewards calculation The issue is that we can only run for a max duration and if someone stakes for the first time after the max duration is over, the reward will always return 0. Thus, we need to restart from the duration that elapsed without generating rewards."
        }
      },
      "getArbitraryStakerCurrentReward(bool,uint256,address)": {
        "details": "getArbitraryStakerCurrentReward function internally calls this function to calculate reward amount",
        "params": {
          "_considerMaxDuration": "True: Runs for the maximum duration - used in tx not to run out of gas False - to query total rewards",
          "_staker": "The staker address to calculate rewards for",
          "_startTime": "The time from which the staking rewards calculation shall restart."
        },
        "return": "The timestamp of last withdrawalThe accumulated reward"
      },
      "getCheckpointBlockNumber(uint256)": {
        "params": {
          "_checkpointTimestamp": "Checkpoint timestamp"
        }
      },
      "getStakerCurrentReward(bool,uint256)": {
        "details": "getStakerCurrentReward function internally calls this function to calculate reward amount of msg.sender",
        "params": {
          "_considerMaxDuration": "True: Runs for the maximum duration - used in tx not to run out of gas False - to query total rewards",
          "_startTime": "The time from which the staking rewards calculation shall restart."
        },
        "return": "The timestamp of last withdrawalThe accumulated reward"
      },
      "initialize(address,address,uint256)": {
        "params": {
          "_averageBlockTime": "average block time used for calculating rewards",
          "_osSOV": "osSOV token address",
          "_staking": "StakingProxy address should be passed"
        }
      },
      "isOwner()": {
        "details": "Returns true if the caller is the current owner."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "setAverageBlockTime(uint256)": {
        "details": "If average block time significantly changes, we can update it here and use for block number calculation",
        "params": {
          "_averageBlockTime": "- average block time used for calculating checkpoint blocks"
        }
      },
      "setHistoricalBlock(uint256)": {
        "params": {
          "_time": "Exact staking checkpoint time"
        }
      },
      "setMaxDuration(uint256)": {
        "details": "Rewards can be collected for a maximum duration at a time. This is to avoid Block Gas Limit failures. Setting it zero would mean that it will loop through the entire duration since the start of rewards program. It should ideally be set to a value, for which the rewards can be easily processed.",
        "params": {
          "_duration": "Max duration for which rewards can be collected at a go (in seconds)"
        }
      },
      "stop()": {
        "details": "Users will only get rewards up to the stop block"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "Staking Rewards Contract."
  },
  "userdoc": {
    "methods": {
      "collectReward(uint256)": {
        "notice": "Collect rewards"
      },
      "getArbitraryStakerCurrentReward(bool,uint256,address)": {
        "notice": "Get any staker's current accumulated reward"
      },
      "getStakerCurrentReward(bool,uint256)": {
        "notice": "Get staker's current accumulated reward"
      },
      "initialize(address,address,uint256)": {
        "notice": "Replacement of constructor by initialize function for Upgradable Contracts This function will be called only once by the owner."
      },
      "setAverageBlockTime(uint256)": {
        "notice": "Changes average block time - based on blockchain"
      },
      "setBlock()": {
        "notice": "This function computes the last staking checkpoint and calculates the corresponding block number using the average block time which is then added to the mapping `checkpointBlockNumber`."
      },
      "setHistoricalBlock(uint256)": {
        "notice": "This function computes the block number using the average block time for a given historical checkpoint which is added to the mapping `checkpointBlockNumber`."
      },
      "setMaxDuration(uint256)": {
        "notice": "Sets the max duration"
      },
      "stop()": {
        "notice": "Stops the current rewards program."
      }
    },
    "notice": "This is a trial incentive program. In this, the osSOV minted to voluntary stakers and is locked until transferred to BitcoinOS"
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 55491,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 25055,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "osSOV",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IERC20Mintable)34134"
      },
      {
        "astId": 25057,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "staking",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IStaking)17840"
      },
      {
        "astId": 25059,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "maxDuration",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 25061,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "rewardsProgramStartTime",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 25063,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "stopBlock",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 25065,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "stopRewardsTimestamp",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 25069,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "stakerNextWithdrawTimestamp",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 25073,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "claimedBalances",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 25075,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "deploymentBlock",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 25079,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "checkpointBlockNumber",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 25081,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "averageBlockTime",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      },
      {
        "astId": 55446,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "_initialized",
        "offset": 0,
        "slot": "12",
        "type": "t_bool"
      },
      {
        "astId": 55448,
        "contract": "contracts/governance/StakingRewards/StakingRewardsOs.sol:StakingRewardsOs",
        "label": "_initializing",
        "offset": 1,
        "slot": "12",
        "type": "t_bool"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20Mintable)34134": {
        "encoding": "inplace",
        "label": "contract IERC20Mintable",
        "numberOfBytes": "20"
      },
      "t_contract(IStaking)17840": {
        "encoding": "inplace",
        "label": "contract IStaking",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}